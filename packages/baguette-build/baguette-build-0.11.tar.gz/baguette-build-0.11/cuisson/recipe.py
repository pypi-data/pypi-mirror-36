#-*- coding:utf-8 -*-
"""
Contains the repice used to deploy.
"""
import base64
import boto3
import fnmatch
import logging
import os
import re
import sys
import farine.settings
import docker
import kaptan
import sel

LOGGER = logging.getLogger(__name__)

class Recipe(object):
    """
    baguette.yaml structure.
    """

    def __init__(self, path, owner, repo, branch, uid):
        """
        Initialize the config.
        :param owner: The owner of the git repo.
        :type owner: str
        :param repo: The name of the git repo.
        :type repo: str
        :param branch: The repo branch.
        :type branch: str
        :param uid: The build unique identifier.
        :type uid: str
        :rtype:None
        """
        #2. Fetch baguette.yaml
        self.config = kaptan.Kaptan(handler="yaml")
        self.config.import_config(path)
        self.config = self.config.configuration_data or {}
        self.path = os.path.dirname(path)
        self.definition = {'owner':owner, 'repo': repo, 'branch' : branch}
        self.api_ns = sel.Request(farine.settings.cuisson['api_namespace'])#pylint:disable=no-member
        self.uid = uid

    def generate_definition(self):
        """
        Given the baguette.yaml, generate the app definition.
        :returns: Status of the baguette.yaml generation
        :rtype bool
        """
        registry_uri = farine.settings.cuisson['registry_domain']#pylint:disable=no-member
        registry_uri = re.findall(r'^http[s]?://(.+)', registry_uri)[0]
        self.definition['uid'] = self.uid
        self.definition['instances'] = self.config.get('instances', 1)
        self.definition['cpu'] = self.config.get('cpu', 0.1)
        self.definition['memory'] = self.config.get('memory', 128)
        self.definition['name'] = '{0}-{1}-{2}'.format(self.definition['owner'], self.definition['repo'], self.definition['branch']).lower()
        #
        tag = '{0}/{1}/{2}:{3}'.format(self.definition['owner'], self.definition['repo'], self.definition['branch'], self.definition['uid']).lower()
        self.definition['tag'] = os.path.join(registry_uri, tag)
        # Private or public
        self.definition['private'] = bool(self.config.get('private', False))
        if self.definition['private']:
            self.definition['domain_name'] = None
        else:
            autogenerated = '{0}-{1}-{2}.{3}'.format(self.definition['owner'], self.definition['repo'], self.definition['branch'], farine.settings.cuisson['domain_name'])
            self.definition['domain_name'] = self.config.get('domain_name', autogenerated)
        # Ports
        protocols = ['tcp', 'udp']
        self.definition['ports'] = []
        for protocol in protocols:
            for port in self.config.get(protocol, []):
                if not isinstance(port, int):
                    continue
                name = '{}-{}'.format(protocol, port)
                self.definition['ports'].append({"number": port, "name": name, "protocol": protocol.upper()})
        # Health checks. Only 2 health checks max : one of each type.
        self.definition['healthchecks'] = []
        default = ['interval_seconds', 'initial_delay_seconds', 'timeout_seconds', 'success_threshold', 'failure_threshold', 'protocol', 'type']
        healthchecks = {}
        healthchecks['COMMAND'] = default + ['value']
        healthchecks['TCP'] = default + ['port']
        healthchecks['HTTP'] = default + ['port', 'path']
        healthchecks['HTTPS'] = default + ['port', 'path']
        types = ['liveness', 'readiness']
        nb_checks = {'liveness':0, 'readiness':0}
        for health in self.config.get('healthchecks', []):
            if not health.get('protocol'):
                continue
            protocol = health['protocol'] = health['protocol'].upper()
            if protocol not in healthchecks:
                continue
            if set(health) != set(healthchecks[protocol]):
                continue
            if health.get('type') not in types:
                continue
            if nb_checks[health['type']] > 0:
                continue
            else:
                nb_checks[health['type']] += 1
            if health['protocol'] == 'COMMAND':
                health['value'] = health['value'].split()
            self.definition['healthchecks'].append({key:value for key, value in health.iteritems()})
        #VPCs
        recette_ns = self.config.get('namespaces', False)
        if recette_ns:
            # Try to iterate over all the ns=>branch pair of the baguette.yaml
            if isinstance(recette_ns, dict):
                recette_ns = [recette_ns]
            match = False
            for d in recette_ns:
                ns, pbranch = d.items()[0]
                if fnmatch.fnmatch(self.definition['branch'], pbranch):
                    req = self.api_ns.get(self.definition['owner'],
                          params={'name':ns},
                          headers={'Authorization':'JWT {0}'.format(farine.settings.cuisson['api_token'])})
                    if req['status'] == 0:
                        self.definition['namespace'] = '{0}-{1}'.format(self.definition['owner'], ns)
                        match = True
                    break
        if not recette_ns or not match:
            self.definition['namespace'] = '{0}-default'.format(self.definition['owner'])

        return True

    def generate_dockerfile(self):
        """
        Parse the yaml file in order to generate the dockerfile.
        :returns: Status of the Dockerfile generation
        :rtype bool
        """
        dockerfile = []
        #1. `languages` statement
        image = self.config.get('language', 'default')#pylint:disable=no-member
        dockerfile.append('FROM {0}'.format(image))
        #2. `packages` statement : TODO: only accept letters and numerics and dash
        if self.config.get('packages'):
            dockerfile.append('RUN apt-get update -y')
            dockerfile.append('RUN apt-get install -y {0}'.format(
                ' '.join(self.config['packages'])))
        #3. Baguette user
        dockerfile.append('RUN addgroup baguette')
        dockerfile.append('RUN useradd -m -g baguette -u 1890 baguette')
        dockerfile.append('USER 1890')
        dockerfile.append('WORKDIR /home/baguette')
        #5. Copy the source code obsviously
        dockerfile.append('COPY --chown=baguette:baguette * /home/baguette/')
        #5. `envs` statements
        for env in self.config.get('envs', []):
            key, value = env.items()[0]
            dockerfile.append('ENV {0}={1}'.format(key, value))
        #6. intermediary `commands` statement
        commands = self.config.get('commands', [])
        exec_ = None if not commands else commands.pop(-1)
        for command in commands:
            dockerfile.append('RUN {0}'.format(command))
        #7. Exec command
        if exec_:
            dockerfile.append('CMD {0}'.format(exec_))
        else:
            dockerfile.append('CMD echo "`commands` statement empty. Nothing to launch.')
        open(os.path.join(self.path, 'Dockerfile'), 'w').write('\n'.join(dockerfile))
        return True

    def build_dockerfile(self):
        """
        Given the dockerfile previously generated, create a docker image.
        :returns: Status of the build
        :rtype bool
        """
        client = docker.DockerClient(base_url='unix://var/run/docker.sock')
        try:
          resp = client.images.build(path=self.path, pull=True, tag=self.definition['tag'], network_mode='host')
        except docker.errors.BuildError as e:
            LOGGER.exception('Build failed.')
            sys.stdout.write('\nBuild failed : %s\n' % str(e))
            return False
        else:
            return True

    def login(self):
        """
        Docker login.
        :returns: The docker session
        :rtype: docker.DockerClient
        """
        aws = boto3.client('ecr', region_name=farine.settings.cuisson['aws_ecr_region'])
        response = aws.get_authorization_token(registryIds=[farine.settings.cuisson['aws_account_id']])
        token = response["authorizationData"][0]["authorizationToken"]
        endpoint = response["authorizationData"][0]["proxyEndpoint"]
        username, password = base64.b64decode(token).split(':')
        client = docker.DockerClient(base_url='unix://var/run/docker.sock')
        client.login(username=username,
                     password=password,
                     registry=farine.settings.cuisson['registry_domain'])
        return client

    def push_dockerfile(self):#pylint:disable=no-self-use
        """
        Given the docker image previously built, push it to the registry.
        Do not forget to remove it locally after that.
        :returns: Status of the push
        :rtype bool
        """
        client = self.login()
        #1. Create the aws repository
        try:
            aws = boto3.client('ecr', region_name=farine.settings.cuisson['aws_ecr_region'])
            aws.create_repository(repositoryName='{0}/{1}/{2}'.format(self.definition['owner'], self.definition['repo'], self.definition['branch']))
        except aws.exceptions.RepositoryAlreadyExistsException: #Already exist
            pass
        #2. Push the image
        for resp in client.images.push(self.definition['tag'], stream=True):
            resp = eval(resp)#pylint:disable=eval-used
            for key, value in resp.iteritems():
                sys.stdout.write('{0} {1}\n'.format(key, value))
                if key == 'error':
                    sys.stdout.write('\nDeployment failed.\n')
                    return False
        return True

    def cleanup(self):
        """
        Cleanup everything related to this tag: the image.
        :returns: the status of the cleanup
        :rtype: bool
        """
        try:
            client = self.login()
            client.images.remove(self.definition['tag'], force=True, noprune=False)
        except docker.errors.APIError:
            LOGGER.exception('Exception during the cleanup of : %s.', self.definition['tag'])
            return False
        return True
