{"version":3,"sources":["webpack:///./js/app/views/testPanels.js","webpack:///./js/app/views/panels.js"],"names":[],"mappings":";;;;;;;;AAAA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;;AAEH;AACA;AACA,IAAG;;AAEH;AACA;AACA,IAAG;;AAEH;AACA;AACA;AACA,MAAK;AACL,+CAA8C;AAC9C,IAAG;;AAEH;AACA;AACA,IAAG;;AAEH;AACA;AACA,IAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAC;;AAED;AACA;AACA;AACA,IAAG;AACH;AACA;AACA,EAAC;;AAED;AACA;;;AAGA;AACA;;AAEA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA,+BAA8B;AAC9B,MAAK;AACL;AACA,IAAG;AACH;AACA;AACA,IAAG;AACH,EAAC;;AAED;AACA;AACA;AACA;AACA,EAAC;;;;;;;;;;;AC/FD;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH,EAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA,EAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA,IAAG;AACH,EAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA,EAAC;;;AAGD;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA;AACA,IAAG;AACH,EAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA,EAAC;;;AAGD;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA,IAAG;AACH,EAAC;;;AAGD;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA,EAAC;;;AAGD;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA,EAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA,IAAG;AACH,EAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA,EAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA,IAAG;AACH,EAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA,EAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;;AAEH;;AAEA;AACA;AACA,IAAG;;AAEH;AACA;AACA,IAAG;;AAEH;AACA,eAAc;AACd,IAAG;;AAEH;AACA,iBAAgB;AAChB,IAAG;;AAEH;AACA;AACA,IAAG;;AAEH;AACA;AACA,IAAG;;AAEH;AACA;AACA,IAAG;;AAEH;;AAEA,IAAG;;AAEH,EAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;;AAEH;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA,IAAG;AACH;AACA;AACA,IAAG;AACH;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;;AAEH;AACA;AACA;AACA;AACA;AACA,IAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA,IAAG;;AAEH;AACA;AACA;AACA;AACA,IAAG;;AAEH;AACA;AACA;AACA,IAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;;AAEH;AACA;AACA,IAAG;;AAEH;AACA;AACA,IAAG;;AAEH;AACA;AACA,IAAG;;AAEH;AACA;AACA,IAAG;;AAEH;AACA;AACA,IAAG;;AAEH;AACA;AACA,IAAG;;AAEH;AACA;AACA,IAAG;;AAEH,EAAC;;;AAGD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;;AAEH;AACA;AACA,IAAG;;AAEH;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;;AAEH;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA,IAAG;;AAEH;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA,IAAG;;AAEH;AACA;AACA;AACA,MAAK;AACL,IAAG;AACH,EAAC;;;;AAID;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;;AAEH;AACA;AACA,IAAG;;AAEH;AACA;AACA;AACA,MAAK;AACL;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA,IAAG;;AAEH;AACA;AACA;AACA,IAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAO;AACP;AACA;AACA;AACA,MAAK;AACL;AACA,IAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAO;AACP;AACA;AACA;AACA,MAAK;AACL;AACA,IAAG;AACH;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA,IAAG;AACH;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,QAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;;AAEH;AACA;AACA;AACA,MAAK;AACL,IAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL,IAAG;;AAEH;AACA;AACA,IAAG;;AAEH;AACA;AACA,IAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH,EAAC;;;AAGD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA,IAAG;AACH;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAO;AACP;AACA;AACA;AACA,MAAK;AACL;AACA,IAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAO;AACP;AACA;AACA;AACA,MAAK;AACL;AACA,IAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA,IAAG;AACH;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA,IAAG;AACH,EAAC;;;AAGD;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAO;AACP,MAAK;AACL;AACA,IAAG;AACH;AACA;AACA;AACA;AACA;AACA,QAAO;AACP;AACA;AACA,MAAK;AACL;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA,MAAK;AACL;AACA,IAAG;AACH;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA,IAAG;AACH;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAO;AACP,MAAK;AACL;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAO;AACP,MAAK;AACL;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA,IAAG;AACH;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA,IAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAW;AACX;AACA;AACA,2CAA0C,MAAM;AAChD;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA,sDAAqD,WAAW;AAChE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA,MAAK;AACL,IAAG;AACH,EAAC;;;AAGD;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;;AAEA;AACA;AACA,IAAG;;AAEH;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA,QAAO;AACP;AACA;AACA;AACA;AACA,IAAG;;AAEH;AACA;AACA;AACA;AACA,IAAG;;AAEH;AACA;AACA,IAAG;AACH;AACA;AACA,IAAG;AACH;AACA;AACA,IAAG;AACH;AACA;AACA,IAAG;AACH;AACA;AACA,IAAG;AACH;AACA;AACA,IAAG;AACH;AACA;AACA,IAAG;AACH;AACA;AACA,IAAG;AACH;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA,IAAG;AACH,EAAC;;;AAGD;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;;AAEH;AACA,uCAAsC;AACtC;AACA,IAAG;AACH;AACA;AACA;AACA;AACA,QAAO;AACP;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAO;AACP;AACA;AACA;AACA,MAAK;AACL;AACA,IAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAO;AACP;AACA;AACA;AACA,MAAK;AACL;AACA,IAAG;;AAEH;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA,IAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA,MAAK;AACL,IAAG,QAAQ,iBAAiB;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG,QAAQ,iBAAiB;AAC5B,EAAC;;;AAGD;AACA;AACA;AACA;AACA;AACA,G","file":"panelTest.js","sourcesContent":["'use strict';\n\nvar Backbone = require('backbone'),\n    Marionette = require('backbone.marionette'),\n    _ = require('underscore'),\n    $ = require('jquery'),\n    panels = require('./panels.js');\n\nvar TestPanel = panels.BasePanel.extend({\n  constructor: function TestPanel() {\n    panels.BasePanel.apply(this, arguments);\n    this.model = new Backbone.Model();\n    if (this.model.get('subpanels') === undefined) {\n      this.model.set('subpanels', []);\n    }\n  },\n\n  ui: {\n    dropdown: '#dropdown',\n  },\n\n  events: {\n    'change @ui.dropdown': 'selectChanged',\n  },\n\n  selectChanged: function(event) {\n    this.model.set('subpanels', _.filter(event.target.value.split('_'), function(x) {\n      return x.length > 0;\n    }));\n    this.wrapper.panelGroup.changeSelection({});\n  },\n\n  getAllowedPanelNames: function() {\n      return this.model.get('subpanels');\n  },\n\n  getAutoactivatedPanelNames: function() {\n      return this.model.get('subpanels');\n  },\n\n  serializeData: function() {\n    return {\n      panelN: this.wrapper.indexInLevel(),\n      levelN: this.wrapper.panelLevel.indexInColumn(),\n      columnN: this.wrapper.panelColumn.indexInColumns(),\n      groupN: this.wrapper.panelGroup.indexInManager(),\n    };\n  },\n\n  name: 'test',\n  className: 'panel test-panel',\n  template: _.template(\n    'G<%= groupN %>C<%= columnN %>L<%= levelN %>P<%= panelN %> '+\n    'choose: <select id=\"dropdown\" name=\"dropdown\">'+\n    '<option id=\"\" selected></option>'+\n    '<option id=\"test\">test</option>'+\n    '<option id=\"test2\">test2</option>'+\n    '<option id=\"test21\">test2_test</option>'+\n    '</select>'),\n});\n\nvar Test2Panel = TestPanel.extend({\n  constructor: function Test2Panel() {\n    TestPanel.apply(this, arguments);\n  },\n  name: 'test2',\n  className: 'panel test2-panel',\n});\n\npanels.PanelManager.prototype.registerPanelClass(TestPanel);\npanels.PanelManager.prototype.registerPanelClass(Test2Panel);\n\n\nvar App =  Marionette.Application.extend({\n  region: '#testapp',\n\n  onStart: function() {\n    this.panelManager = new panels.PanelManager({\n      rootName: 'test',\n    });\n    this.showView(this.panelManager);\n    this.panelManager.children.each(function(group) {\n      group.changeSelection({});\n    });\n    $(window).on(\"resize\", _.bind(this.windowResized, this));\n  },\n  windowResized: function() {\n    this.panelManager.resize(window.innerWidth);\n  },\n});\n\ndocument.addEventListener('DOMContentLoaded', () => {\n  var app = new App();\n  window.app = app;\n  app.start();\n});\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./js/app/views/testPanels.js\n// module id = 0\n// module chunks = 2","'use strict';\n\n// Note on animation: https://github.com/marionettejs/backbone.marionette/issues/320\n// https://github.com/marcinkrysiak1979/marionette.showAnimated/blob/master/backbone.marionette.showAnimated.js\n\n/**\n *\n * @module app.views.panels\n */\n\nvar Backbone = require('backbone'),\n    Marionette = require('backbone.marionette'),\n    _ = require('underscore');\n\n\nfunction assert(condition, msg) {\n  if (!condition) {\n    console.error(msg || \"error\");\n    debugger;\n  }\n}\n\n/**\n * @class app.views.panels.ViewModel\n */\nvar ViewModel = Backbone.Model.extend({\n  constructor: function ViewModel() {\n    Backbone.Model.apply(this, arguments);\n  },\n});\n\n/**\n * @class app.views.panels.ViewModelCollection\n */\nvar ViewModelCollection = Backbone.Collection.extend({\n  constructor: function ViewModelCollection() {\n    Backbone.Collection.apply(this, arguments);\n  },\n  model: ViewModel,\n});\n\n/**\n * @class app.views.panels.PanelModel\n */\nvar PanelModel = ViewModel.extend({\n  constructor: function PanelModel() {\n    ViewModel.apply(this, arguments);\n  },\n  defaults: {\n    panelName: '',\n    minimized: false,\n  },\n});\n\n/**\n * @class app.views.panels.PanelModelCollection\n */\nvar PanelModelCollection = ViewModelCollection.extend({\n  constructor: function PanelModelCollection() {\n    ViewModelCollection.apply(this, arguments);\n  },\n  model: PanelModel,\n});\n\n\n/**\n * @class app.views.panels.PanelLevelModel\n */\nvar PanelLevelModel = ViewModel.extend({\n  constructor: function PanelLevelModel() {\n    ViewModel.apply(this, arguments);\n  },\n  defaults: function() {\n    return {\n      collection: new PanelModelCollection(),\n      heightAdjustment: 2,\n    };\n  },\n});\n\n/**\n * @class app.views.panels.PanelLevelModelCollection\n */\nvar PanelLevelModelCollection = ViewModelCollection.extend({\n  constructor: function PanelLevelModelCollection() {\n    ViewModelCollection.apply(this, arguments);\n  },\n  model: PanelLevelModel,\n});\n\n\n/**\n * @class app.views.panels.PanelColumnModel\n */\nvar PanelColumnModel = ViewModel.extend({\n  constructor: function PanelColumnModel() {\n    ViewModel.apply(this, arguments);\n  },\n  defaults: function() {\n    return {\n      collection: new PanelLevelModelCollection(),\n    };\n  },\n});\n\n\n/**\n * @class app.views.panels.PanelColumnModelCollection\n */\nvar PanelColumnModelCollection = ViewModelCollection.extend({\n  constructor: function PanelColumnModelCollection() {\n    ViewModelCollection.apply(this, arguments);\n  },\n  model: PanelColumnModel,\n});\n\n\n/**\n * @class app.views.panels.PanelGroupModelCollection\n */\nvar PanelGroupModelCollection = ViewModelCollection.extend({\n  constructor: function PanelGroupModelCollection() {\n    ViewModelCollection.apply(this, arguments);\n  },\n  model: PanelGroupModel,\n});\n\n/**\n * @class app.views.panels.PanelGroupModel\n */\nvar PanelGroupModel = ViewModel.extend({\n  constructor: function PanelGroupModel() {\n    ViewModel.apply(this, arguments);\n  },\n  defaults: function() {\n    return {\n      collection: new PanelColumnModelCollection(),\n    };\n  },\n});\n\n/**\n * @class app.views.panels.PanelGroupModelCollection\n */\nvar PanelGroupModelCollection = ViewModelCollection.extend({\n  constructor: function PanelGroupModelCollection() {\n    ViewModelCollection.apply(this, arguments);\n  },\n  model: PanelGroupModel,\n});\n\n/**\n * @class app.views.panels.PanelManagerModel\n */\nvar PanelManagerModel = ViewModel.extend({\n  constructor: function PanelManagerModel() {\n    ViewModel.apply(this, arguments);\n  },\n  defaults: function() {\n    return {\n      collection: new PanelGroupModelCollection(),\n    };\n  },\n});\n\n/**\n * @class app.views.panels.PanelManagerModelCollection\n */\nvar PanelManagerModelCollection = ViewModelCollection.extend({\n  constructor: function PanelManagerModelCollection() {\n    ViewModelCollection.apply(this, arguments);\n  },\n  model: PanelManagerModel,\n});\n\n/**\n * An abstract class every panel should eventually extend\n * @class app.views.views.BasePanel\n */\nvar BasePanel = Marionette.View.extend({\n  constructor: function BasePanel() {\n    Marionette.View.apply(this, arguments);\n  },\n\n  name: '',\n\n  registerClass: function() {\n    PanelManager.prototype.registerPanelClass(this);\n  },\n\n  changeSelection: function(selectionChanges) {\n    //\n  },\n\n  getAllowedPanelNames: function() {\n    return [];  // String[]\n  },\n\n  getAutoactivatedPanelNames: function() {\n      return [];  // String[]\n  },\n\n  getMinWidth: function() {\n      return 200;\n  },\n\n  getMaxWidth: function() {\n      return 1500;\n  },\n\n  getMinHeight: function() {\n      return 20;\n  },\n\n  setMinimize: function(minimize) {\n    \n  },\n\n});\n\n/**\n * An abstract class every panel should eventually extend\n * @class app.views.views.PanelWrapper\n */\nvar PanelWrapper = Marionette.View.extend({\n  constructor: function PanelWrapper() {\n    Marionette.View.apply(this, arguments);\n  },\n\n  ui: {\n    panel: '.panelc',\n    header: '.panelw-header',\n    minButton: '.js_min',\n  },\n  regions: {\n    panelR: '@ui.panel',\n    header: '@ui.header',\n  },\n  events: {\n    'click @ui.minButton': 'toggleMinimize',\n  },\n  className: \"panel-w\",\n  template: _.template(\"<div class='panelw-header'><%= panelName %><button class='js_min'><%= minSymbol %></button></div><div class='panelc'></div>\"),\n\n  initialize: function(options) {\n    this.minimized = !!this.model.get('minimized');\n    this.panelManager = options.panelManager;\n    this.panelGroup = options.panelGroup;\n    this.panelLevel = options.panelLevel;\n    this.panelColumn = options.panelColumn;\n    this.panelColumns = options.panelColumns;\n  },\n\n  serializeData: function() {\n    return {\n      panelName: this.model.get('panelName'),\n      minSymbol: (this.minimized)?'+':'-',\n    };\n  },\n\n  onRender: function(options) {\n    var panelName = this.model.get('panelName'),\n        panel = PanelManager.prototype.createPanelByName(panelName);\n    if (panel) {\n      panel.wrapper = this;\n      this.panel = panel;\n      this.showChildView('panelR', panel);\n    } else {\n      this.ui.panel.text(\"Cannot find \"+panelName)\n    }\n  },\n\n  onAttach: function() {\n    if (this.minimized) {\n      this.$el.addClass('minimized');\n    }\n  },\n\n  toggleMinimize: function() {\n    this.setMinimize(!this.minimized);\n    this.$el.find('.js_min').text((this.minimized)?'+':'-');\n  },\n\n  setMinimize: function(minimized) {\n    if (minimized !== this.minimized) {\n      // console.log(\"setting min of panel G\"+this.panelGroup.indexInManager()\n      // +\"C\"+this.panelColumn.indexInColumns()+\"L\"+this.panelLevel.indexInColumn()\n      // +\"P\"+this.indexInLevel()+\" to \"+minimized);\n      if (minimized) {\n        this.$el.addClass('minimized');\n      } else {\n        this.$el.removeClass('minimized');\n      }\n      this.minimized = minimized;\n      this.model.set('minimized', minimized);\n      this.panel.setMinimize(minimized);\n      this.panelLevel.updateMinimize(this);\n      this.panelManager.updateMinimize(this);\n      this.panelManager.resetPercent();\n    }\n  },\n\n  indexInLevel: function() {\n    return this.panelLevel.panelCollection.collection.indexOf(this.model);\n  },\n\n  getAllowedPanelNames: function() {\n    return this.panel.getAllowedPanelNames();\n  },\n\n  getAutoactivatedPanelNames: function() {\n    return this.panel.getAutoactivatedPanelNames();\n  },\n\n  getMinWidth: function() {\n    return this.panel.getMinWidth();\n  },\n\n  getMaxWidth: function() {\n    return this.panel.getMaxWidth();\n  },\n\n  getMinHeight: function() {\n    return this.panel.getMinHeight() + 20;\n  },\n\n  changeSelection: function(selectionChanges) {\n    return this.panel.changeSelection(selectionChanges);\n  },\n\n});\n\n\n/**\n * @class app.views.views.PanelCollection\n */\nvar PanelCollection = Marionette.CollectionView.extend({\n  constructor: function PanelCollection() {\n    // Is it a Marionette object or an abstraction?\n    // Clearly the former in the case of a multipanel level, at least.\n    Marionette.CollectionView.apply(this, arguments);\n  },\n  singlePanel: true,\n  className: 'panel-collection',\n  initialize: function(options) {\n    this.collection = this.model.get('collection');\n    this.panelManager = options.panelManager;\n    this.panelGroup = options.panelGroup;\n    this.panelColumn = options.panelColumn;\n    this.panelColumns = options.panelColumns;\n    this.panelLevel = options.panelLevel;\n  },\n\n  getPanelWrappers: function() {\n    return this.children;\n  },\n\n  childView: PanelWrapper,\n\n  childViewOptions: function() {\n    return {\n      panelManager: this.panelManager,\n      panelGroup: this.panelGroup,\n      panelColumn: this.panelColumn,\n      panelColumns: this.panelColumns,\n      panelLevel: this.panelLevel,\n    };\n  },\n\n  _addPanel: function(panelName, minimized) {\n    // check for duplicates? Do we allow them?\n    this.collection.push(new PanelModel({\n      panelName: panelName,\n      minimized: minimized,\n    }));\n    this.panelManager.updateMinimize();\n  },\n\n  _removePanel: function(panel) {\n    var model = this.collection.find(function(model) {\n      return model === panel.wrapper.model;\n    });\n    if (model != null) {\n      this.collection.remove(model);\n      this.panelManager.updateMinimize();\n    }\n    // panel.terminate() // or whatever needed to avoid leaks\n  },\n\n  changeSelection: function(selectionChanges) {\n    this.getPanelWrappers().each(function(panel) {\n      panel.changeSelection(selectionChanges);\n    });\n  },\n});\n\n\n\n/**\n * @class app.views.views.PanelLevel\n */\nvar PanelLevel = Marionette.View.extend({\n  constructor: function PanelLevel() {\n    // Is it a Marionette object or an abstraction?\n    // Clearly the former in the case of a multipanel level, at least.\n    Marionette.View.apply(this, arguments);\n  },\n  template: _.template(\"<div class='level-header'>G<%= groupN %>C<%= columnN %>L<%= levelN %></div><div class='panels'></div>\"),\n  singlePanel: true,\n  className: 'panel-level',\n  ui: {\n    panels: '.panels',\n    header: '.level-header',\n  },\n  regions: {\n    panels: '@ui.panels',\n    header: '@ui.header',\n  },\n  initialize: function(options) {\n    this.minimized = !!this.model.get('minimized');\n    this.panelManager = options.panelManager;\n    this.panelGroup = options.panelGroup;\n    this.panelColumn = options.panelColumn;\n    this.panelColumns = options.panelColumns;\n    options.panelLevel = this;\n    this.panelCollection = new PanelCollection(options);\n    this.singlePanel = options.singlePanel;\n    this.allowedPanelNames = [];\n  },\n\n  serializeData: function() {\n    return {\n      levelN: this.indexInColumn(),\n      columnN: this.panelColumn.indexInColumns(),\n      groupN: this.panelGroup.indexInManager(),\n    };\n  },\n\n  onRender: function() {\n    this.showChildView('panels', this.panelCollection);\n  },\n\n  onAttach: function() {\n    if (this.minimized) {\n      this.$el.addClass('minimized');\n    } else {\n      this.adjustModelHeight();\n    }\n  },\n  adjustModelHeight: function(heightAdjustment) {\n    if (heightAdjustment === undefined) {\n      heightAdjustment = this.model.get('heightAdjustment');\n    }\n    this.$el.css('height', 'calc(100% - '+heightAdjustment+'px)');\n  },\n  getPanelWrappers: function() {\n    return this.panelCollection.getPanelWrappers();\n  },\n\n  indexInColumn: function() {\n    // coming soon\n    return this.panelColumn.collection.indexOf(this.model);\n  },\n\n  addPanel: function(panelName) {\n    this.panelCollection._addPanel(panelName);\n    var multiPanel = (this.panelCollection.collection.length > 1);\n    if (multiPanel && this.singlePanel) {\n      console.log('error');\n      return;\n    }\n  },\n  getMinWidth: function() {\n    var panels = this.getPanelWrappers(),\n        width = 0,\n        previousIsMinimized = false;\n    panels.each(function(panel) {\n      var panelWidth = panel.getMinWidth();\n      if (previousIsMinimized) {\n        width = Math.max(width, panelWidth);\n      } else {\n        width += panelWidth;\n      }\n      previousIsMinimized = panel.minimized;\n    });\n    return width;\n  },\n  getMaxWidth: function() {\n    var panels = this.getPanelWrappers(),\n        width = 0,\n        previousIsMinimized = false;\n    panels.each(function(panel) {\n      var panelWidth = panel.getMaxWidth();\n      if (previousIsMinimized) {\n        width = Math.min(width, panelWidth);\n      } else {\n        width += panelWidth;\n      }\n      previousIsMinimized = panel.minimized;\n    });\n    return width;\n  },\n  getMinHeight: function() {\n    var panels = this.getPanelWrappers(),\n        height = 0;\n    panels.each(function(wrapper) {\n      height += wrapper.getMinHeight();\n    });\n    return height;\n  },\n  updateMinimize: function(panel) {\n    var minimized = this.getPanelWrappers().all(function(p) {\n      return p.minimized;\n    });\n    if (minimized !== this.minimized) {\n      // console.log(\"setting min of level G\"+this.panelGroup.indexInManager()\n      // +\"C\"+this.panelColumn.indexInColumns()+\"L\"+this.indexInColumn()+\" to \"+minimized);\n      if (minimized) {\n        this.$el.addClass('minimized');\n        panel.$el.css('height', '');\n      } else {\n        this.$el.removeClass('minimized');\n      }\n      this.minimized = minimized;\n      this.model.set('minimized', minimized);\n      this.panelColumns.updateMinimize(this);\n      this.panelGroup.updateMinimize(panel);\n    }\n  },\n\n  nextPanelToMinimize: function() {\n    return this.getPanelWrappers().find(function(panel) {\n      return !panel.minimized;\n    });\n  },\n\n  nextPanelToUnminimize: function() {\n    var panels = this.getPanelWrappers()\n    // reverse\n    panels = panels.last(panels.length);\n    return _.find(panels, function(panel) {\n      return panel.minimized;\n    });\n  },\n\n  removePanel: function(panel) {\n    this.panelCollection._removePanel(panel);\n  },\n\n  changeSelection: function(selectionChanges) {\n    this.panelCollection.changeSelection(selectionChanges);\n  },\n\n  resetWithNames: function(allowedPanelNames, autoactivatedPanelNames) {\n    var that = this,\n        change = false,\n        panels = this.getPanelWrappers(),\n        numActive = panels.length;\n    panels.each(function(panel) {\n      if (!_.contains(allowedPanelNames, panel.panel.name)) {\n        that.removePanel(panel.panel);\n        numActive -= 1;\n        change = true;\n      }\n    });\n    // assumption: Only autoactivate if nothing active.\n    if (autoactivatedPanelNames.length && !numActive) {\n      this.addPanel(autoactivatedPanelNames[0]);\n      numActive += 1;\n      change = true;\n    }\n    this.allowedPanelNames = allowedPanelNames;\n    return change;\n  },\n});\n\n\n/**\n * PanelColumn aka PanelLevelCollection\n * @class app.views.views.PanelColumn\n */\nvar PanelColumn = Marionette.CollectionView.extend({\n  constructor: function PanelColumn() {\n    Marionette.CollectionView.apply(this, arguments);\n  },\n  initialize: function(options) {\n    this.rootName = options.rootName;\n    this.panelManager = options.panelManager;\n    this.panelGroup = options.panelGroup;\n    this.panelColumns = options.panelColumns;\n    this.collection = this.model.get('collection');\n  },\n  indexInColumns: function() {\n    return this.panelColumns.collection.indexOf(this.model);\n  },\n  className: 'panel-column',\n  childView: PanelLevel,\n  getLevels: function() {\n    return this.children;\n  },\n  getSelection: function() {\n    return this.panelGroup.getSelection();\n  },\n  pushLevel: function() {\n    this.collection.add(new PanelLevelModel());\n  },\n  childViewOptions: function(view, index) {\n    return {\n      panelManager: this.panelManager,\n      panelGroup: this.panelGroup,\n      panelColumns: this.panelColumns,\n      panelColumn: this,\n    };\n  },\n  removeLastLevel: function() {\n    this.collection.pop();\n  },\n  getLastLevel: function() {\n    var lastModel = this.collection.last();\n    if (lastModel) {\n      return this.children.findByModel(lastModel);\n    }\n  },\n  getMinWidth: function() {\n    var levels = this.getLevels(),\n        width = 0,\n        previousIsMinimized = false;\n    levels.each(function(level) {\n      var levelWidth = level.getMinWidth();\n      if (previousIsMinimized) {\n        width = Math.min(width, levelWidth);\n      } else {\n        width += levelWidth;\n      }\n      previousIsMinimized = level.minimized;\n    });\n    return width;\n  },\n  adjustLevelHeight: function() {\n    var lastLevelModel = this.collection.last(),\n        lastLevel = this.children.findByModel(lastLevelModel),\n        minHeight = 2 + this.getMinimizedHeight();\n    console.log(\"adjusting level G\"+this.panelGroup.indexInManager()+\"C\"+this.indexInColumns()+\"L\"+lastLevel.indexInColumn()+\" to \"+minHeight);\n    lastLevelModel.set('heightAdjustment', minHeight);\n    lastLevel.adjustModelHeight(minHeight);\n  },\n  getMaxWidth: function(panel) {\n    var levels = this.getLevels(),\n        width = 0,\n        previousIsMinimized = false;\n    levels.each(function(level) {\n      var levelWidth = level.getMaxWidth();\n      if (previousIsMinimized) {\n        width = Math.min(width, levelWidth);\n      } else {\n        width += levelWidth;\n      }\n      previousIsMinimized = level.minimized;\n    });\n    return width;\n  },\n  getMinimizedHeight: function() {\n    var levels = this.getLevels(),\n        height = 0;\n    levels.each(function(level) {\n      if (level.minimized) {\n        height += level.getMinHeight();\n      }\n    });\n    return height;\n  },\n  nextLevel: function(level) {\n    var i = this.collection.indexOf(level.model);\n    if (i < this.children.length - 1) {\n      return this.children.findByModel(this.collection.at(i+1));\n    }\n  },\n  resetPercent: function(minWidth) {\n    var myMinWidth = this.getMinWidth();\n    this.$el.css(\"width\", (100.0*myMinWidth/minWidth)+\"%\");\n  },\n});\n\n\n/**\n * @class app.views.views.PanelColumnCollection\n */\nvar PanelColumnCollection = Marionette.CollectionView.extend({\n  constructor: function PanelColumnCollection() {\n    Marionette.CollectionView.apply(this, arguments);\n  },\n  initialize: function(options) {\n    this.rootName = options.rootName;\n    this.panelManager = options.panelManager;\n    this.panelGroup = options.panelGroup;\n    this.rootName = options.rootName;\n    this.collection = this.model.get('collection');\n  },\n  className: 'panel-column-collection',\n  childView: PanelColumn,\n  getColumns: function() {\n    return this.children;\n  },\n  getLevels: function() {\n    var that = this,\n        levels = [];\n    // costly for no good reason.\n    this.collection.each(function(columnModel) {\n      var column = that.children.findByModel(columnModel);\n      column.collection.each(function(levelModel) {\n        var level = column.children.findByModel(levelModel);\n        levels.push(level);\n      });\n    });\n    return levels;\n  },\n  getLevelByIndex: function(i) {\n    var column = this.children.find(function(column) {\n      if (i >= column.children.length) {\n        i -= column.children.length;\n        return false;\n      } else {\n        return true;\n      }\n    });\n    if (column) {\n      return column.children.findByModel(column.collection.at(i));\n    }\n  },\n  nextColumn: function(column) {\n    var i = this.collection.indexOf(column.model);\n    if (i < this.children.length - 1) {\n      return this.children.findByModel(this.collection.at(i+1));\n    }\n  },\n  previousColumn: function(column) {\n    var i = this.collection.indexOf(column.model);\n    if (i > 0) {\n      return this.children.findByModel(this.collection.at(i-1));\n    }\n  },\n  nextLevel: function(level) {\n    var other = level.panelColumn.nextLevel(level);\n    if (other) {\n      return other;\n    }\n    other = this.nextColumn(level.panelColumn);\n    if (other) {\n      return other.children[0];\n    }\n  },\n  countLevels: function() {\n    var numLevels = 0;\n    this.children.each(function(column) {\n      numLevels += column.collection.length;\n    });\n    return numLevels;\n  },\n  getSelection: function() {\n    return this.panelGroup.getSelection();\n  },\n  childViewOptions: function(view, index) {\n    return {\n      panelManager: this.panelManager,\n      panelGroup: this.panelGroup,\n      rootName: this.rootName,\n      panelColumns: this,\n    };\n  },\n  pushColumn: function() {\n    this.collection.add(new PanelColumnModel());\n  },\n  pushLevel: function() {\n    this.pushColumn();\n    this.children.last().pushLevel();\n  },\n  removeLastLevel: function() {\n    assert(this.collection.length > 0, \"no columns?\");\n    var columnModel = this.collection.last(),\n        view = this.children.findByModel(columnModel);\n    assert(view.collection.length > 0, \"no level in column?\");\n    view.removeLastLevel();\n    if (view.getLevels().length == 0) {\n      this.collection.pop();\n    }\n  },\n  changeSelection: function(selectionChanges) {\n    var numLevels = this.countLevels(),\n        allowedPanelNames = [this.rootName],\n        autoactivatedPanelNames = allowedPanelNames,\n        pos = 0,\n        level,\n        change = false,\n        autoactivate = true;\n    while (autoactivate) {\n      while (pos >= numLevels) {\n        this.pushLevel();\n        numLevels++;\n        change = true;\n      }\n      level = this.getLevelByIndex(pos++);\n      change = level.resetWithNames(allowedPanelNames, autoactivatedPanelNames) || change;\n      allowedPanelNames = [];\n      autoactivate = false;\n      autoactivatedPanelNames = [];\n      level.getPanelWrappers().each(function(panel) {\n        panel.changeSelection(selectionChanges);\n        allowedPanelNames = allowedPanelNames.concat(panel.getAllowedPanelNames());\n        autoactivatedPanelNames = autoactivatedPanelNames.concat(panel.getAutoactivatedPanelNames());\n      });\n      if (allowedPanelNames.length === 0) {\n        while (numLevels > pos) {\n          this.removeLastLevel();\n          numLevels--;\n          change = true;\n        }\n        break;\n      }\n      autoactivate = autoactivatedPanelNames.length > 0;\n      // remove duplicates in autoactivatedPanelNames/allowedPanel names, but keep order.\n      // Make sure autoactivated panel names are in the front of allowedPanelNames.\n      // Not sure how to handle different priorities... as things\n      // stand, first panel dominates. Maybe interleave? Rarely an issue.\n    }\n    if (change) {\n      this.panelManager.resetPercent();\n    }\n  },\n\n  nextPanelToMinimize: function() {\n    var that = this,\n        panels = [];\n    this.collection.each(function (model) {\n      var column = that.children.findByModel(model);\n      column.collection.each(function(levelModel) {\n        var level = column.children.findByModel(levelModel),\n            panel = level.nextPanelToMinimize();\n        if (panel) {\n          panels.push(panel);\n        }\n      });\n    });\n    if (panels.length) {\n      return panels[0];\n    }\n  },\n  nextPanelToUnminimize: function() {\n    var that = this,\n        panels = [];\n    this.collection.each(function (model) {\n      var column = that.children.findByModel(model);\n      column.collection.each(function(levelModel) {\n        var level = column.children.findByModel(levelModel),\n            panel = level.nextPanelToUnminimize();\n        if (panel) {\n          panels.push(panel);\n        }\n      });\n    });\n    if (panels.length) {\n      // TODO: Sort by depth\n      panels.reverse();\n      return panels[0];\n    }\n  },\n  getMinWidth: function() {\n    var columns = this.getColumns(),\n        width = 0;\n    columns.each(function(column) {\n      width += column.getMinWidth();\n    });\n    return width;\n  },\n  getMaxWidth: function() {\n    var columns = this.getColumns(),\n        width = 0;\n    columns.each(function(column) {\n      width += column.getMaxWidth();\n    });\n    return width;\n  },\n  updateMinimize: function(panelLevel) {\n    if (panelLevel.minimized) {\n      // level was just minimized, recreate that panel and all panels\n      // of that column (should all be minimized)\n      // in the next column (if any.)\n      assert(panelLevel.indexInColumn()\n        == panelLevel.panelColumn.collection.length - 1,\n        \"should be last level\");\n      var sourceCol = panelLevel.panelColumn,\n          targetCol = this.nextColumn(sourceCol);\n      if (targetCol) {\n        var models = sourceCol.collection.models.slice();\n        if (models.length > 1) {\n          assert(_.all(models, function (model) {\n            return !!model.get('minimized');\n          }), \"previous models should be minimized\");\n        }\n        sourceCol.collection.remove(models);\n        targetCol.collection.add(models, {at: 0});\n        this.collection.remove(sourceCol.model);\n        targetCol.adjustLevelHeight();\n        this.render();\n      }\n    } else {\n      // level was just maximized, shift it (and previous minimized levels)\n      // to new previous column. Not needed if last level\n      var nextLevel = this.nextLevel(panelLevel);\n      if (nextLevel) {\n        var colNum = panelLevel.panelColumn.indexInColumns();\n        this.collection.add(new PanelColumnModel(), {at: colNum});\n        var sourceCol = panelLevel.panelColumn,\n            targetCol = this.children.findByModel(this.collection.at(colNum)),\n            levelIndex = panelLevel.indexInColumn(),\n            models = sourceCol.collection.models.slice(0, levelIndex + 1);\n        sourceCol.collection.remove(models);\n        sourceCol.adjustLevelHeight();\n        targetCol.collection.add(models);\n        targetCol.adjustLevelHeight();\n      }\n    }\n  },\n  resetPercent: function(minWidth) {\n    this.children.each(function(column) {\n      column.resetPercent(minWidth);\n    });\n  },\n});\n\n\n/**\n * @class app.views.views.PanelGroup\n */\nvar PanelGroup = Marionette.View.extend({\n  constructor: function PanelGroup() {\n    Marionette.View.apply(this, arguments);\n  },\n  template: _.template(\"<div class='group-header'>G<%= groupN %><button class='closeButton'>x</button></div><div class='columns'></div>\"),\n  ui: {\n    closeButton: \".closeButton\",\n    columns: \".columns\",\n  },\n  regions: {\n    columns: \"@ui.columns\",\n  },\n  initialize: function(options) {\n    this.minimized = !!this.model.get('minimized');\n    this.rootName = options.rootName;\n    this.collection = this.model.get('collection');\n    this.panelManager = options.panelManager;\n    options.panelGroup = this;\n    this.columnsC = new PanelColumnCollection(options);\n    this.selection = {};\n  },\n  className: 'panel-group',\n  rootName: '',\n\n  indexInManager: function() {\n    return this.panelManager.collection.indexOf(this.model);\n  },\n\n  updateMinimize: function(panel) {\n    // TODO: Rewrite as columns\n    var minimized = _.all(this.getLevels(), function(p) {\n      return p.minimized;\n    });\n    if (minimized !== this.minimized) {\n      // console.log(\"setting min of group G\"+this.indexInManager()+\" to \"+minimized);\n      if (minimized) {\n        this.$el.addClass('minimized');\n      } else {\n        this.$el.removeClass('minimized');\n      }\n      this.minimized = minimized;\n    }\n  },\n\n  serializeData: function() {\n    return {\n      groupN: this.indexInManager(),\n    };\n  },\n\n  getLevels: function() {\n    return this.columnsC.getLevels();\n  },\n  getSelection: function() {\n    return this.selection;\n  },\n  onRender: function() {\n    this.showChildView('columns', this.columnsC);\n  },\n  removeLastLevel: function() {\n    this.columnsC.removeLastLevel();\n  },\n  nextPanelToMinimize: function() {\n    return this.columnsC.nextPanelToMinimize();\n  },\n  nextPanelToUnminimize: function() {\n    return this.columnsC.nextPanelToUnminimize();\n  },\n  getMinWidth: function() {\n    return this.columnsC.getMinWidth();\n  },\n  getMaxWidth: function(panel) {\n    return this.columnsC.getMaxWidth();\n  },\n  changeSelection: function(selectionChanges) {\n    _.extend(this.selection, selectionChanges);\n    return this.columnsC.changeSelection(selectionChanges);\n  },\n  resetPercent: function(minWidth) {\n    var myMinWidth = this.getMinWidth();\n    this.$el.css(\"width\", (100.0*myMinWidth/minWidth)+\"%\");\n    this.columnsC.resetPercent(myMinWidth);\n  },\n});\n\n\n/**\n * @class app.views.views.PanelManager\n */\nvar PanelManager = Marionette.CollectionView.extend({\n  constructor: function PanelManager() {\n    Marionette.CollectionView.apply(this, arguments);\n  },\n  className: 'panel-manager fitting',\n  leftMargin: 5,\n  rightMargin: 5,\n  groupMargin: 5,\n  fitToWindow: true,\n  childView: PanelGroup,\n  initialize: function(options) {\n    this.rootName = options.rootName;\n    this.model = new PanelManagerModel();\n    this.collection = this.model.get('collection');\n    this.collection.add(new PanelGroupModel());\n    this.resetPercent();\n  },\n  childViewOptions: function(view, index) {\n    return {\n      rootName: this.rootName,\n      panelManager: this,\n    };\n  },\n  getGroups: function() {\n    return this.children;\n  },\n  panelClassesByName: new Object(),\n  registerPanelClass: function(cls) {\n    // called on the prototype\n    this.panelClassesByName[cls.prototype.name] = cls;\n  },\n  createPanelByName: function(name) {\n    // called on the prototype\n    var cls = this.panelClassesByName[name];\n    if (cls != null) {\n      return new cls(arguments);\n    }\n  },\n\n  canFit: function(width) {\n    var minWidth = this.getMinWidth(); // ordered somehow\n    return minWidth <= width;\n  },\n  setFitToWindow: function(fitToWindow) {\n    if (this.fitToWindow !== fitToWindow) {\n      if (fitToWindow) {\n        this.$el.addClass('fitting');\n      } else {\n        this.$el.removeClass('fitting');\n      }\n      this.fitToWindow = fitToWindow;\n    }\n    // and recalc css if actually changed.\n  },\n  updateMinimize: function(panel) {\n    var canFit = this.canFit(window.innerWidth);\n    if (this.fitToWindow !== canFit) {\n      this.setFitToWindow(canFit);\n    }\n  },\n  getMinWidth: function(panel) {\n    var groups = this.getGroups(),\n        previousIsMinimized = false,\n        margin = this.groupMargin,\n        width = -margin;\n    groups.each(function(group) {\n      var groupWidth = group.getMinWidth();\n      if (previousIsMinimized) {\n        width = Math.min(width, groupWidth);\n      } else {\n        width += groupWidth + margin;\n      }\n      previousIsMinimized = group.minimized;\n    });\n    return width + this.leftMargin + this.rightMargin;\n  },\n\n  getMaxWidth: function(panel) {\n    var groups = this.getGroups(),\n        previousIsMinimized = false,\n        margin = this.groupMargin,\n        width = -margin;\n    groups.each(function(group) {\n      var groupWidth = group.getMaxWidth();\n      if (previousIsMinimized) {\n        width = Math.min(width, groupWidth);\n      } else {\n        width += groupWidth + margin;\n      }\n      previousIsMinimized = group.minimized;\n    });\n    return width + this.leftMargin + this.rightMargin;\n  },\n\n  getMaxWidth: function(panel) {\n    var groups = this.getGroups(),\n        width = this.groupMargin * (groups.length - 1) + this.leftMargin + this.rightMargin;\n    groups.each(function(group) {\n      width += group.getMaxWidth();\n    });\n    return width;\n  },\n  nextPanelToMinimize: function() {\n    var groups = this.getGroups(),\n        panels = [];\n    groups.each(function(group) {\n      var panel = group.nextPanelToMinimize();\n      if (panel != null) {\n        panels.push(panel);\n      }\n    });\n    // TODO: Choose the one with the lowest depth... ideally not the latest active group?\n    if (panels.length) {\n      return panels[0];\n    }\n  },\n  nextPanelToUnminimize: function() {\n    var groups = this.getGroups(), panels = [];\n    groups.each(function(group) {\n      var panel = group.nextPanelToUnminimize();\n      if (panel != null) {\n        panels.push(panel);\n      }\n    });\n    // TODO: Choose the one with the lowest depth... ideally not the latest active group?\n    if (panels.length) {\n      return panels[0];\n    }\n  },\n  resetPercent: _.throttle(function() {\n    var minWidth = this.getMinWidth();\n    this.children.each(function(group) {\n      group.resetPercent(minWidth);\n    });\n  }, 100, { leading: false }),\n  resize: _.throttle(function(newWidth) {\n      // cases:\n      // not fitting, growing: see if fits. if so, fall to next step.\n      // fit, growing: unminimize while fits.\n      // fit, growing smaller: if stops fitting, minimize until fits? not sure.\n      // not fitting, growing smaller: do nothing.\n      // TODO: Add a delay function to this, and make sure it does not happen too often\n      var nextPanelWidth,\n          change = false,\n          minWidth = this.getMinWidth(),\n          canFit = minWidth <= newWidth;\n      while (canFit) {\n        var panel = this.nextPanelToUnminimize();\n        if (panel == undefined) {\n          // TODO Can we minimize a group, in that case?\n          break;\n        }\n        nextPanelWidth = panel.getMinWidth();\n        if (minWidth + nextPanelWidth > newWidth) {\n          break;\n        }\n        panel.setMinimize(false);\n        change = true;\n        minWidth = this.getMinWidth();\n        canFit = this.canFit(newWidth);\n      }\n      if (this.fitToWindow && ! canFit) {\n        while (!canFit) {\n          var panel = this.nextPanelToMinimize();\n          if (panel == undefined) {\n            break;\n          }\n          panel.setMinimize(true);\n        change = true;\n          minWidth = this.getMinWidth();\n          canFit = this.canFit(newWidth);\n        }\n      }\n      if (canFit && !this.fitToWindow) {\n        this.setFitToWindow(canFit);\n      }\n      if (change) {\n        this.resetPercent();\n      }\n  }, 100, { leading: false }),\n});\n\n\nmodule.exports = {\n  BasePanel: BasePanel,\n  PanelLevel: PanelLevel,\n  PanelManager: PanelManager,\n  PanelGroup: PanelGroup,\n};\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./js/app/views/panels.js\n// module id = 363\n// module chunks = 2"],"sourceRoot":""}