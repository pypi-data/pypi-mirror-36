#include <errno.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdint.h>

#include "vtk_io.h"

// VTK encodes binary image data as big-endian, so a conversion
// may be needed according to the architecture.

#define IS_BIG_ENDIAN (*(uint16_t*) "\0\xff" < 0x100)

static inline FLOATING _swap_float_32(const FLOATING value) {
    FLOATING result;
    char *result_ptr = (char*) &result;
    char *input_ptr = (char*) &value;

    result_ptr[0] = input_ptr[3];
    result_ptr[1] = input_ptr[2];
    result_ptr[2] = input_ptr[1];
    result_ptr[3] = input_ptr[0];

    return result;
}

static inline FLOATING _swap_float_64(const FLOATING value) {
    FLOATING result;
    char *result_ptr = (char*) &result;
    char *input_ptr = (char*) &value;

    result_ptr[0] = input_ptr[7];
    result_ptr[1] = input_ptr[6];
    result_ptr[2] = input_ptr[5];
    result_ptr[3] = input_ptr[4];
    result_ptr[4] = input_ptr[3];
    result_ptr[5] = input_ptr[2];
    result_ptr[6] = input_ptr[1];
    result_ptr[7] = input_ptr[0];

    return result;
}

// Slower but size-agnostic fallback
static inline FLOATING _swap_float_any(const FLOATING value) {
    FLOATING result;
    char *p = (char*) &value;
    char *q = (char*) &result;
    unsigned i;
    for (i = 0; i < sizeof (FLOATING); ++i) {
        q[i] = p[sizeof (FLOATING) - i - 1];
    }
    return result;
}

// Dummy for big-endian, will be erased by the compiler
// if optimisation is enabled
static inline FLOATING _swap_nothing(const FLOATING value) {
    return value;
}

// Choose the right function according to the size of the type
#define swapping_function \
    ((IS_BIG_ENDIAN) ? _swap_nothing : \
     (sizeof (FLOATING) == 4) ? _swap_float_32 : \
     (sizeof (FLOATING) == 8) ? _swap_float_64 : \
     _swap_float_any)

/*!
 * \brief Write to file a vector field in VTK (STRUCTURED_POINTS) format.
 * \return 0 on success, negative value on failure.
 * \note In case of failure, `disptools_error` is set.
 */
int write_vtk(
        const char *filename, /*!< Filename */
        const Image f         /*!< Resulting image */
        )
{
    size_t i = 0ul;

    // Allocate a buffer and copy the image data in it
    double *buffer = (double*) malloc(f.nd * f.nx * f.ny * f.nz * sizeof (double));
    if (!buffer) {
        DISPTOOLS_SET_ERROR(true, strerror(errno));
        return -1;
    }

    FLOATING (* const swap_bytes)(FLOATING) = swapping_function;

    for (size_t z = 0; z < f.nz; ++z) {
        for (size_t y = 0; y < f.ny; ++y) {
            for (size_t x = 0; x < f.nx; ++x) {
                for (size_t d = 0; d < f.nd; ++d) {
                    buffer[i++] = swap_bytes(_(f, x, y, z, d));
                }
            }
        }
    }

    FILE *fp = fopen(filename, "wb");
    if(!fp) {
        free(buffer);
        DISPTOOLS_SET_ERROR(true, strerror(errno));
        return -1;
    }

    fprintf(fp,
            "# vtk DataFile Version 3.0\n"
            "Generated by %s defined in %s\n"
            "BINARY\n"
            "DATASET STRUCTURED_POINTS\n"
            "DIMENSIONS %zu %zu %zu\n"
            "ORIGIN 0 0 0\n"
            "SPACING %f %f %f\n"
            "POINT_DATA %zu\n"
            "SCALARS image_data double %zu\n"
            "LOOKUP_TABLE default\n",
            __func__,
            __FILE__,
            f.nx, f.ny, f.nz,
            f.dx, f.dy, f.dz,
            f.nx * f.ny * f.nz,
            f.nd
            );
    fwrite(buffer, sizeof (double), f.nd * f.nx * f.ny * f.nz, fp);

    fclose(fp);
    free(buffer);

    return 0;
}

/*!
 * \brief Read from file a vector field in VTK (STRUCTURED_POINTS) format.
 * \return 0 on success, negative value on failure.
 * \note In case of failure, `disptools_error` is set.
 */
int read_vtk(
        const char *filename, /*!< Filename */
        Image *image          /*!< Resulting image */
        )
{
    size_t nx = 0, ny = 0, nz = 0, nd = 0;
    float fdx, fdy, fdz;
    FLOATING dx, dy, dz;
    size_t i = 0ul;

    FLOATING (* const swap_bytes)(FLOATING) = swapping_function;

    const unsigned buf_len = 255u;
    char line_buffer[buf_len];

    FILE *fp = fopen(filename, "rb");
    if(!fp) {
        DISPTOOLS_SET_ERROR(true, strerror(errno));
        return -1;
    }

    int flt = 0;
    int dbl = 0;

    // This is a simple but ugly solution to parse the header
    while (fgets(line_buffer, buf_len, fp) && line_buffer[0] != 'L') {
        sscanf(line_buffer, "DIMENSIONS %zu %zu %zu", &nx, &ny, &nz);
        sscanf(line_buffer, "SPACING %f %f %f", &fdx, &fdy, &fdz);
        dbl = sscanf(line_buffer, "SCALARS %*s double %zu", &nd);
        flt = sscanf(line_buffer, "SCALARS %*s float %zu", &nd);
    }
    dx = (FLOATING) fdx;
    dy = (FLOATING) fdy;
    dz = (FLOATING) fdz;

    // TODO add float support
    if (flt) {
        DISPTOOLS_SET_ERROR(true, "float type not supported");
        return -1;
    }

    verbose_printf(DISPTOOLS_DEBUG, "%zu %zu %zu %zu %f %f %f\n", nd, nx, ny, nz, dx, dy, dz);

    // Allocate memory for a buffer and read image data

    const size_t element_count = nd * nx * ny * nz;

    double *buffer = (double*) malloc(element_count * sizeof (double));
    if(!buffer) {
        DISPTOOLS_SET_ERROR(true, strerror(errno));
    }

    fread(buffer, sizeof (double), element_count, fp);

    fclose(fp);

    // Allocate memory for the data structure
    *image = new_image(nd, nx, ny, nz, dx, dy, dz);

    if (disptools_error.error) {
        free(buffer);
        return -1;
    }

    // Copy data from the buffer to the data structure
    Image ptr = *image;
    for (size_t z = 0; z < image->nz; ++z) {
        for (size_t y = 0; y < image->ny; ++y) {
            for (size_t x = 0; x < image->nx; ++x) {
                for (size_t d = 0; d < image->nd; ++d) {
                    _(ptr, x, y, z, d) = swap_bytes(buffer[i++]);
                }
            }
        }
    }

    free(buffer);

    return 0;
}
