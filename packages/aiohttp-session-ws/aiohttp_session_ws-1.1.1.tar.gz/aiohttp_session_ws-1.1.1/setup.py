# -*- coding: utf-8 -*-
from distutils.core import setup

packages = \
['aiohttp_session_ws']

package_data = \
{'': ['*']}

install_requires = \
['aiohttp>=3.4,<4.0', 'aiohttp_session>=2.5,<3.0']

setup_kwargs = {
    'name': 'aiohttp-session-ws',
    'version': '1.1.1',
    'description': 'session-managed websockets for aiohttp',
    'long_description': '====================\n`aiohttp_session_ws`\n====================\n\n.. image:: https://travis-ci.org/dfee/aiohttp_session_ws.svg?branch=master\n    :target: https://travis-ci.org/dfee/aiohttp_session_ws\n.. image:: https://coveralls.io/repos/github/dfee/aiohttp_session_ws/badge.svg?branch=master\n    :target: https://coveralls.io/github/dfee/aiohttp_session_ws?branch=master\n\n\nSimply put: associate your websockets with a user\'s session, and close those connections when you see fit.\n\nFor example, let\'s say you\'re using `aiohttp_security <https://pypi.org/project/aiohttp_security/>`_ and a user chooses to log in or log out.\nUsing ``aiohttp_session_ws`` you can disconnect the open websocket subscriptions associated with their session, and force them to re-connect and re-authorize thier websocket subscriptions.\n\n.. image:: demo/demo.gif\n\n\nBasic Example\n-------------\n\nThe pieces of code in this example are taken from the ``demo`` directory of this repository.\n\n.. code-block:: python\n\n    async def handle_root(request):\n        return web.Response(text=\'Hello world\', content_type="text/html")\n\n    async def handle_reset(request):\n        session_ws_id = await get_session_ws_id(request)\n        response = web.Response(\n            text=f"Reset called on session {session_ws_id}!",\n            content_type="text/plain",\n        )\n        await schedule_close_all_session_ws(request, response)\n        await new_session_ws_id(request)\n        return response\n\n    async def handle_websocket(request):\n        async with session_ws(request) as wsr:\n            connected_at = datetime.now()\n            session_ws_id = await get_session_ws_id(request)\n            while True:\n                await wsr.send_str(\n                    f"Websocket associated with session [{session_ws_id}] "\n                    f"connected for {(datetime.now() - connected_at).seconds}"\n                )\n                await asyncio.sleep(1)\n            return wsr\n\n    def make_app():\n        app = web.Application(\n            middlewares=[\n                aiohttp_session.session_middleware(\n                    aiohttp_session.SimpleCookieStorage()\n                ),\n                session_ws_middleware,\n            ]\n        )\n        app.router.add_get("/", handle_root)\n        app.router.add_get("/reset", handle_reset)\n        app.router.add_get("/ws", handle_websocket)\n\n        setup_session_websockets(app, SessionWSRegistry())\n        return app\n\nUse the code from the ``demo`` folder, which includes a simple template to interact with the websocket in your web-browser.\n\n\nNarrative API\n-------------\n\nThis package is designed to be straightforward and easy to use.\nThis lightweight documentation doesn\'t attempt to replace the need to read the code, so you\'re encouraged to go do exactly that.\n\nThere are a few moving pieces, but if (and when) you need to do something more complex, you can subclass away.\n\n\n``SessionWSRegistry``\n~~~~~~~~~~~~~~~~~~~~~\nThis is the core of ``aiohttp_session_ws``.\n\nIt\'s construction is noteworthy:\n\n``SessionWSRegistry(self, *, id_factory, session_key)``\n\n``id_factory`` generates a session-wide id that associates the websockets.\nThe default id_factory returns a UUID4, but you can supply your own callable (async callables are supported, too).\nthe function signature of ``id_factory`` is:\n\n``id_factory(request: aiohttp.web.Request) -> typing.Hashable``\n\nSo pretty much, return something that can be the key in a dictionary (strings, integers, etc.).\n\n``session_key`` is the name of the key in the session that maps to the session-wide websocket identifier.\nBy default it\'s a sensible ``aiohttp_session_ws_id``.\n\n\nHelpers\n~~~~~~~\n\nYou won\'t need to interact with ``SessionWSRegistry`` directly after you\'ve created it, but know that it\'s available in your ``aiohttp.web.Application`` (access it like this: ``app[\'aiohttp_session_ws_registry\']``).\n\nThe friendly global manipulators of this object are:\n\n- ``get_session_ws_id(request)``\n- ``new_session_ws_id(request)``\n- ``delete_session_ws_id(request)``\n- ``ensure_session_ws_id(request)``\n- ``schedule_close_all_session_ws(request, response)``\n\nThese methods are importable directly from ``aiohttp_session_ws``.\n\nNotice that ``schedule_close_all_session_ws`` takes a response object.\nThis allows us to end the ``keep-alive`` status of the response (via ``aiohttp.web.Response.force_close``).\nThis means that as soon as your user has finished receiveing the response, their outstanding websockets will close.\n\nThis also means that if you have users with re-connecting websockets, you should probably follow this pattern:\n\n.. code-block:: python\n\n    async def handle_logout(request):\n        response = web.HTTPFound(\'/\')\n        await schedule_close_all_session_ws(request, response)\n        await aiohttp_session.new_session(request)\n        await new_session_ws_id(request)\n        return response\n\n\nsession_ws\n~~~~~~~~~~\n\nTo track the websockets, you\'ll use the async context manager ``session_ws``.\nThis context manager upgrades the request, and provides its ``aiothttp.web.WebSocketResponse`` counterpart.\nUse if like this:\n\n.. code-block:: python\n\n    async def handle_websocket(request):\n        async with session_ws(request) as wsr:\n            async for msg in wsr:\n                await wsr.send_str(f\'Heard: {ws.data}\')\n            return wsr\n\nThat\'s it. Pretty simple, right?\nIf you\'d like to provide the ``aiohttp.web.WebSocketResponse`` with initialization options (for example, the supported websocket protocols), pass those along to ``session_ws`` as named arguments.\n\n.. code-block:: python\n\n    async def handle_websocket(request):\n        async with session_ws(request, protocols=(\'graphql-ws\',)) as wsr:\n            async for msg in wsr:\n                await wsr.send_str(f\'Heard: {ws.data}\')\n            return wsr\n\n\nAs mentioned in the *Notes* below, it\'s important that your users have a ``session_ws id`` prior to attempting a websocket connection (hint: Safari).\n\nUse the ``session_ws_middleware`` to automatically add the key to your sessions.\nIt should be inside the call-stack of ``aiohttp_session.session_middleware``:\n\n.. code-block:: python\n\n    web.Application(\n        middlewares=[\n            aiohttp_session.session_middleware(\n                aiohttp_session.SimpleCookieStorage()\n            ),\n            session_ws_middleware,\n        ]\n    )\n\n\nFinally, to set all of this up, you\'ll want to use the ``setup`` method (feel encourged to import it as ``setup_session_ws``).\n\nBasic usage looks like this:\n\n.. code-block:: python\n\n    web.Application(\n        middlewares=[\n            aiohttp_session.session_middleware(\n                aiohttp_session.SimpleCookieStorage()\n            ),\n            session_ws_middleware,\n        ]\n    )\n    setup(app, SessionWSRegistry())  # <------\n    # etc...\n    return app\n\n\nNotes\n-----\n\nWhile ``session_ws`` generates an ``aiohttp_session_ws_id`` upon connect (if it\'s not present), some browsers don\'t respect ``Set-Cookie`` on a websocket upgrade (e.g. Safari).\n\nTherefore it\'s best if you ensure that an ``aiohttp_session_ws_id`` is present in the users session prior to attempting a websocket connection (if using ``aiohttp_session.SimpleCookieStorage`` or ``aiohttp_session.EncryptedCookieStorage``).\n\nIf you\'re using something more advanced that stores a reference to the session in the session cookie, and stores the actual value server-side (like ``aiohttp_session.RedisStorage``), then it\'s not important when ``aiohttp_session_ws_id`` is set on the cookie, but it is still important that the user has a session cookie prior to a connection attempt.\n\nIf you want to put the session-ws-id (usually ``aiohttp_session_ws_id``) somewhere else in the session, or derive it from the request, you can.\nSimply subclass ``SessionWSRegistry`` and revise the ``get_id``, ``set_id``, and ``delete_id`` methods.\n\nIf you have a cluster of webservers, you\'ll need to subclass ``SessionWSRegistry`` and revise the ``register`` and ``unregister`` functions so listen on a message broker (for example, using ``aioredis`` and its pubsub feature).',
    'author': 'Devin Fee',
    'author_email': 'devin@devinfee.com',
    'url': 'https://github.com/dfee/aiohttp_session_ws',
    'packages': packages,
    'package_data': package_data,
    'install_requires': install_requires,
    'python_requires': '>=3.5,<4.0',
}


setup(**setup_kwargs)
