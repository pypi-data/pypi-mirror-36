

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>twisted.python.filepath &mdash; Cohen3 0.8.0 documentation</title>
  

  
  
  
  

  

  
  
    

  

  <link rel="stylesheet" href="../../../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css" />
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" /> 

  
  <script src="../../../_static/js/modernizr.min.js"></script>

</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search">
          

          
            <a href="../../../index.html" class="icon icon-home"> Cohen3
          

          
          </a>

          
            
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul>
<li class="toctree-l1"><a class="reference internal" href="../../../install.html">Installation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../cli.html">Command-Line Interface</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../backends.html">Backends (plugins)</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../source/coherence.html">Coherence (package)</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../contributing.html">Contributing</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../contributor_code_of_conduct.html">Contributor Covenant Code of Conduct</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../changelog.html">Changelog</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../index.html">Cohen3</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../../../index.html">Docs</a> &raquo;</li>
        
          <li><a href="../../index.html">Module code</a> &raquo;</li>
        
      <li>twisted.python.filepath</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <h1>Source code for twisted.python.filepath</h1><div class="highlight"><pre>
<span></span><span class="c1"># -*- test-case-name: twisted.test.test_paths -*-</span>
<span class="c1"># Copyright (c) Twisted Matrix Laboratories.</span>
<span class="c1"># See LICENSE for details.</span>

<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">Object-oriented filesystem path representation.</span>
<span class="sd">&quot;&quot;&quot;</span>

<span class="kn">from</span> <span class="nn">__future__</span> <span class="k">import</span> <span class="n">division</span><span class="p">,</span> <span class="n">absolute_import</span>

<span class="kn">import</span> <span class="nn">os</span>
<span class="kn">import</span> <span class="nn">sys</span>
<span class="kn">import</span> <span class="nn">errno</span>
<span class="kn">import</span> <span class="nn">base64</span>

<span class="kn">from</span> <span class="nn">os.path</span> <span class="k">import</span> <span class="n">isabs</span><span class="p">,</span> <span class="n">exists</span><span class="p">,</span> <span class="n">normpath</span><span class="p">,</span> <span class="n">abspath</span><span class="p">,</span> <span class="n">splitext</span>
<span class="kn">from</span> <span class="nn">os.path</span> <span class="k">import</span> <span class="n">basename</span><span class="p">,</span> <span class="n">dirname</span><span class="p">,</span> <span class="n">join</span> <span class="k">as</span> <span class="n">joinpath</span>
<span class="kn">from</span> <span class="nn">os</span> <span class="k">import</span> <span class="n">listdir</span><span class="p">,</span> <span class="n">utime</span><span class="p">,</span> <span class="n">stat</span>

<span class="kn">from</span> <span class="nn">stat</span> <span class="k">import</span> <span class="n">S_ISREG</span><span class="p">,</span> <span class="n">S_ISDIR</span><span class="p">,</span> <span class="n">S_IMODE</span><span class="p">,</span> <span class="n">S_ISBLK</span><span class="p">,</span> <span class="n">S_ISSOCK</span>
<span class="kn">from</span> <span class="nn">stat</span> <span class="k">import</span> <span class="n">S_IRUSR</span><span class="p">,</span> <span class="n">S_IWUSR</span><span class="p">,</span> <span class="n">S_IXUSR</span>
<span class="kn">from</span> <span class="nn">stat</span> <span class="k">import</span> <span class="n">S_IRGRP</span><span class="p">,</span> <span class="n">S_IWGRP</span><span class="p">,</span> <span class="n">S_IXGRP</span>
<span class="kn">from</span> <span class="nn">stat</span> <span class="k">import</span> <span class="n">S_IROTH</span><span class="p">,</span> <span class="n">S_IWOTH</span><span class="p">,</span> <span class="n">S_IXOTH</span>

<span class="kn">from</span> <span class="nn">zope.interface</span> <span class="k">import</span> <span class="n">Interface</span><span class="p">,</span> <span class="n">Attribute</span><span class="p">,</span> <span class="n">implementer</span>

<span class="c1"># Please keep this as light as possible on other Twisted imports; many, many</span>
<span class="c1"># things import this module, and it would be good if it could easily be</span>
<span class="c1"># modified for inclusion in the standard library.  --glyph</span>

<span class="kn">from</span> <span class="nn">twisted.python.compat</span> <span class="k">import</span> <span class="n">comparable</span><span class="p">,</span> <span class="nb">cmp</span><span class="p">,</span> <span class="n">unicode</span>
<span class="kn">from</span> <span class="nn">twisted.python.deprecate</span> <span class="k">import</span> <span class="n">deprecated</span>
<span class="kn">from</span> <span class="nn">twisted.python.runtime</span> <span class="k">import</span> <span class="n">platform</span>
<span class="kn">from</span> <span class="nn">incremental</span> <span class="k">import</span> <span class="n">Version</span>

<span class="kn">from</span> <span class="nn">twisted.python.win32</span> <span class="k">import</span> <span class="n">ERROR_FILE_NOT_FOUND</span><span class="p">,</span> <span class="n">ERROR_PATH_NOT_FOUND</span>
<span class="kn">from</span> <span class="nn">twisted.python.win32</span> <span class="k">import</span> <span class="n">ERROR_INVALID_NAME</span><span class="p">,</span> <span class="n">ERROR_DIRECTORY</span><span class="p">,</span> <span class="n">O_BINARY</span>
<span class="kn">from</span> <span class="nn">twisted.python.win32</span> <span class="k">import</span> <span class="ne">WindowsError</span>

<span class="kn">from</span> <span class="nn">twisted.python.util</span> <span class="k">import</span> <span class="n">FancyEqMixin</span>

<span class="n">_CREATE_FLAGS</span> <span class="o">=</span> <span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">O_EXCL</span> <span class="o">|</span>
                 <span class="n">os</span><span class="o">.</span><span class="n">O_CREAT</span> <span class="o">|</span>
                 <span class="n">os</span><span class="o">.</span><span class="n">O_RDWR</span> <span class="o">|</span>
                 <span class="n">O_BINARY</span><span class="p">)</span>



<span class="k">def</span> <span class="nf">_stub_islink</span><span class="p">(</span><span class="n">path</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Always return C{False} if the operating system does not support symlinks.</span>

<span class="sd">    @param path: A path string.</span>
<span class="sd">    @type path: L{str}</span>

<span class="sd">    @return: C{False}</span>
<span class="sd">    @rtype: L{bool}</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="kc">False</span>


<span class="n">islink</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="p">,</span> <span class="s1">&#39;islink&#39;</span><span class="p">,</span> <span class="n">_stub_islink</span><span class="p">)</span>
<span class="n">randomBytes</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">urandom</span>
<span class="n">armor</span> <span class="o">=</span> <span class="n">base64</span><span class="o">.</span><span class="n">urlsafe_b64encode</span>



<span class="k">class</span> <span class="nc">IFilePath</span><span class="p">(</span><span class="n">Interface</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    File path object.</span>

<span class="sd">    A file path represents a location for a file-like-object and can be</span>
<span class="sd">    organized into a hierarchy; a file path can can children which are</span>
<span class="sd">    themselves file paths.</span>

<span class="sd">    A file path has a name which unique identifies it in the context of its</span>
<span class="sd">    parent (if it has one); a file path can not have two children with the same</span>
<span class="sd">    name.  This name is referred to as the file path&#39;s &quot;base name&quot;.</span>

<span class="sd">    A series of such names can be used to locate nested children of a file</span>
<span class="sd">    path; such a series is referred to as the child&#39;s &quot;path&quot;, relative to the</span>
<span class="sd">    parent.  In this case, each name in the path is referred to as a &quot;path</span>
<span class="sd">    segment&quot;; the child&#39;s base name is the segment in the path.</span>

<span class="sd">    When representing a file path as a string, a &quot;path separator&quot; is used to</span>
<span class="sd">    delimit the path segments within the string.  For a file system path, that</span>
<span class="sd">    would be C{os.sep}.</span>

<span class="sd">    Note that the values of child names may be restricted.  For example, a file</span>
<span class="sd">    system path will not allow the use of the path separator in a name, and</span>
<span class="sd">    certain names (e.g. C{&quot;.&quot;} and C{&quot;..&quot;}) may be reserved or have special</span>
<span class="sd">    meanings.</span>

<span class="sd">    @since: 12.1</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">sep</span> <span class="o">=</span> <span class="n">Attribute</span><span class="p">(</span><span class="s2">&quot;The path separator to use in string representations&quot;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">child</span><span class="p">(</span><span class="n">name</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Obtain a direct child of this file path.  The child may or may not</span>
<span class="sd">        exist.</span>

<span class="sd">        @param name: the name of a child of this path. C{name} must be a direct</span>
<span class="sd">            child of this path and may not contain a path separator.</span>
<span class="sd">        @return: the child of this path with the given C{name}.</span>
<span class="sd">        @raise InsecurePath: if C{name} describes a file path that is not a</span>
<span class="sd">            direct child of this file path.</span>
<span class="sd">        &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">open</span><span class="p">(</span><span class="n">mode</span><span class="o">=</span><span class="s2">&quot;r&quot;</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Opens this file path with the given mode.</span>

<span class="sd">        @return: a file-like object.</span>
<span class="sd">        @raise Exception: if this file path cannot be opened.</span>
<span class="sd">        &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">changed</span><span class="p">():</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Clear any cached information about the state of this path on disk.</span>
<span class="sd">        &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">getsize</span><span class="p">():</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Retrieve the size of this file in bytes.</span>

<span class="sd">        @return: the size of the file at this file path in bytes.</span>
<span class="sd">        @raise Exception: if the size cannot be obtained.</span>
<span class="sd">        &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">getModificationTime</span><span class="p">():</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Retrieve the time of last access from this file.</span>

<span class="sd">        @return: a number of seconds from the epoch.</span>
<span class="sd">        @rtype: L{float}</span>
<span class="sd">        &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">getStatusChangeTime</span><span class="p">():</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Retrieve the time of the last status change for this file.</span>

<span class="sd">        @return: a number of seconds from the epoch.</span>
<span class="sd">        @rtype: L{float}</span>
<span class="sd">        &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">getAccessTime</span><span class="p">():</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Retrieve the time that this file was last accessed.</span>

<span class="sd">        @return: a number of seconds from the epoch.</span>
<span class="sd">        @rtype: L{float}</span>
<span class="sd">        &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">exists</span><span class="p">():</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Check if this file path exists.</span>

<span class="sd">        @return: C{True} if the file at this file path exists, C{False}</span>
<span class="sd">            otherwise.</span>
<span class="sd">        @rtype: L{bool}</span>
<span class="sd">        &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">isdir</span><span class="p">():</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Check if this file path refers to a directory.</span>

<span class="sd">        @return: C{True} if the file at this file path is a directory, C{False}</span>
<span class="sd">            otherwise.</span>
<span class="sd">        &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">isfile</span><span class="p">():</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Check if this file path refers to a regular file.</span>

<span class="sd">        @return: C{True} if the file at this file path is a regular file,</span>
<span class="sd">            C{False} otherwise.</span>
<span class="sd">        &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">children</span><span class="p">():</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        List the children of this path object.</span>

<span class="sd">        @return: a sequence of the children of the directory at this file path.</span>
<span class="sd">        @raise Exception: if the file at this file path is not a directory.</span>
<span class="sd">        &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">basename</span><span class="p">():</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Retrieve the final component of the file path&#39;s path (everything</span>
<span class="sd">        after the final path separator).</span>

<span class="sd">        @return: the base name of this file path.</span>
<span class="sd">        @rtype: L{str}</span>
<span class="sd">        &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">parent</span><span class="p">():</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        A file path for the directory containing the file at this file path.</span>
<span class="sd">        &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">sibling</span><span class="p">(</span><span class="n">name</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        A file path for the directory containing the file at this file path.</span>

<span class="sd">        @param name: the name of a sibling of this path.  C{name} must be a</span>
<span class="sd">            direct sibling of this path and may not contain a path separator.</span>

<span class="sd">        @return: a sibling file path of this one.</span>
<span class="sd">        &quot;&quot;&quot;</span>


<span class="k">class</span> <span class="nc">InsecurePath</span><span class="p">(</span><span class="ne">Exception</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Error that is raised when the path provided to L{FilePath} is invalid.</span>
<span class="sd">    &quot;&quot;&quot;</span>



<span class="k">class</span> <span class="nc">LinkError</span><span class="p">(</span><span class="ne">Exception</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    An error with symlinks - either that there are cyclical symlinks or that</span>
<span class="sd">    symlink are not supported on this platform.</span>
<span class="sd">    &quot;&quot;&quot;</span>



<span class="k">class</span> <span class="nc">UnlistableError</span><span class="p">(</span><span class="ne">OSError</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    An exception which is used to distinguish between errors which mean &#39;this</span>
<span class="sd">    is not a directory you can list&#39; and other, more catastrophic errors.</span>

<span class="sd">    This error will try to look as much like the original error as possible,</span>
<span class="sd">    while still being catchable as an independent type.</span>

<span class="sd">    @ivar originalException: the actual original exception instance, either an</span>
<span class="sd">        L{OSError} or a L{WindowsError}.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">originalException</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Create an UnlistableError exception.</span>

<span class="sd">        @param originalException: an instance of OSError.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="vm">__dict__</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">originalException</span><span class="o">.</span><span class="vm">__dict__</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">originalException</span> <span class="o">=</span> <span class="n">originalException</span>



<span class="k">class</span> <span class="nc">_WindowsUnlistableError</span><span class="p">(</span><span class="n">UnlistableError</span><span class="p">,</span> <span class="ne">WindowsError</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    This exception is raised on Windows, for compatibility with previous</span>
<span class="sd">    releases of FilePath where unportable programs may have done &quot;except</span>
<span class="sd">    WindowsError:&quot; around a call to children().</span>

<span class="sd">    It is private because all application code may portably catch</span>
<span class="sd">    L{UnlistableError} instead.</span>
<span class="sd">    &quot;&quot;&quot;</span>



<span class="k">def</span> <span class="nf">_secureEnoughString</span><span class="p">(</span><span class="n">path</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Compute a string usable as a new, temporary filename.</span>

<span class="sd">    @param path: The path that the new temporary filename should be able to be</span>
<span class="sd">        concatenated with.</span>

<span class="sd">    @return: A pseudorandom, 16 byte string for use in secure filenames.</span>
<span class="sd">    @rtype: the type of C{path}</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">secureishString</span> <span class="o">=</span> <span class="n">armor</span><span class="p">(</span><span class="n">randomBytes</span><span class="p">(</span><span class="mi">16</span><span class="p">))[:</span><span class="mi">16</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">_coerceToFilesystemEncoding</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="n">secureishString</span><span class="p">)</span>



<span class="k">class</span> <span class="nc">AbstractFilePath</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Abstract implementation of an L{IFilePath}; must be completed by a</span>
<span class="sd">    subclass.</span>

<span class="sd">    This class primarily exists to provide common implementations of certain</span>
<span class="sd">    methods in L{IFilePath}. It is *not* a required parent class for</span>
<span class="sd">    L{IFilePath} implementations, just a useful starting point.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">getContent</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Retrieve the contents of the file at this path.</span>

<span class="sd">        @return: the contents of the file</span>
<span class="sd">        @rtype: L{bytes}</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">with</span> <span class="bp">self</span><span class="o">.</span><span class="n">open</span><span class="p">()</span> <span class="k">as</span> <span class="n">fp</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">fp</span><span class="o">.</span><span class="n">read</span><span class="p">()</span>


    <span class="k">def</span> <span class="nf">parents</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Retrieve an iterator of all the ancestors of this path.</span>

<span class="sd">        @return: an iterator of all the ancestors of this path, from the most</span>
<span class="sd">        recent (its immediate parent) to the root of its filesystem.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">path</span> <span class="o">=</span> <span class="bp">self</span>
        <span class="n">parent</span> <span class="o">=</span> <span class="n">path</span><span class="o">.</span><span class="n">parent</span><span class="p">()</span>
        <span class="c1"># root.parent() == root, so this means &quot;are we the root&quot;</span>
        <span class="k">while</span> <span class="n">path</span> <span class="o">!=</span> <span class="n">parent</span><span class="p">:</span>
            <span class="k">yield</span> <span class="n">parent</span>
            <span class="n">path</span> <span class="o">=</span> <span class="n">parent</span>
            <span class="n">parent</span> <span class="o">=</span> <span class="n">parent</span><span class="o">.</span><span class="n">parent</span><span class="p">()</span>


    <span class="k">def</span> <span class="nf">children</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        List the children of this path object.</span>

<span class="sd">        @raise OSError: If an error occurs while listing the directory.  If the</span>
<span class="sd">        error is &#39;serious&#39;, meaning that the operation failed due to an access</span>
<span class="sd">        violation, exhaustion of some kind of resource (file descriptors or</span>
<span class="sd">        memory), OSError or a platform-specific variant will be raised.</span>

<span class="sd">        @raise UnlistableError: If the inability to list the directory is due</span>
<span class="sd">        to this path not existing or not being a directory, the more specific</span>
<span class="sd">        OSError subclass L{UnlistableError} is raised instead.</span>

<span class="sd">        @return: an iterable of all currently-existing children of this object.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">subnames</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">listdir</span><span class="p">()</span>
        <span class="k">except</span> <span class="ne">WindowsError</span> <span class="k">as</span> <span class="n">winErrObj</span><span class="p">:</span>
            <span class="c1"># Under Python 3.3 and higher on Windows, WindowsError is an</span>
            <span class="c1"># alias for OSError.  OSError has a winerror attribute and an</span>
            <span class="c1"># errno attribute.</span>

            <span class="c1"># Under Python 2, WindowsError is an OSError subclass.</span>

            <span class="c1"># Under Python 2.5 and higher on Windows, WindowsError has a</span>
            <span class="c1"># winerror attribute and an errno attribute.</span>

            <span class="c1"># The winerror attribute is bound to the Windows error code while</span>
            <span class="c1"># the errno attribute is bound to a translation of that code to a</span>
            <span class="c1"># perhaps equivalent POSIX error number.</span>
            <span class="c1">#</span>
            <span class="c1"># For further details, refer to:</span>
            <span class="c1"># https://docs.python.org/3/library/exceptions.html#OSError</span>

            <span class="c1"># If not for this clause OSError would be handling all of these</span>
            <span class="c1"># errors on Windows.  The errno attribute contains a POSIX error</span>
            <span class="c1"># code while the winerror attribute contains a Windows error code.</span>
            <span class="c1"># Windows error codes aren&#39;t the same as POSIX error codes,</span>
            <span class="c1"># so we need to handle them differently.</span>

            <span class="c1"># Under Python 2.4 on Windows, WindowsError only has an errno</span>
            <span class="c1"># attribute.  It is bound to the Windows error code.</span>

            <span class="c1"># For simplicity of code and to keep the number of paths through</span>
            <span class="c1"># this suite minimal, we grab the Windows error code under either</span>
            <span class="c1"># version.</span>

            <span class="c1"># Furthermore, attempting to use os.listdir on a non-existent path</span>
            <span class="c1"># in Python 2.4 will result in a Windows error code of</span>
            <span class="c1"># ERROR_PATH_NOT_FOUND.  However, in Python 2.5,</span>
            <span class="c1"># ERROR_FILE_NOT_FOUND results instead. -exarkun</span>
            <span class="n">winerror</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">winErrObj</span><span class="p">,</span> <span class="s1">&#39;winerror&#39;</span><span class="p">,</span> <span class="n">winErrObj</span><span class="o">.</span><span class="n">errno</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">winerror</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">(</span><span class="n">ERROR_PATH_NOT_FOUND</span><span class="p">,</span>
                                <span class="n">ERROR_FILE_NOT_FOUND</span><span class="p">,</span>
                                <span class="n">ERROR_INVALID_NAME</span><span class="p">,</span>
                                <span class="n">ERROR_DIRECTORY</span><span class="p">):</span>
                <span class="k">raise</span>
            <span class="k">raise</span> <span class="n">_WindowsUnlistableError</span><span class="p">(</span><span class="n">winErrObj</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">OSError</span> <span class="k">as</span> <span class="n">ose</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">ose</span><span class="o">.</span><span class="n">errno</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">(</span><span class="n">errno</span><span class="o">.</span><span class="n">ENOENT</span><span class="p">,</span> <span class="n">errno</span><span class="o">.</span><span class="n">ENOTDIR</span><span class="p">):</span>
                <span class="c1"># Other possible errors here, according to linux manpages:</span>
                <span class="c1"># EACCES, EMIFLE, ENFILE, ENOMEM.  None of these seem like the</span>
                <span class="c1"># sort of thing which should be handled normally. -glyph</span>
                <span class="k">raise</span>
            <span class="k">raise</span> <span class="n">UnlistableError</span><span class="p">(</span><span class="n">ose</span><span class="p">)</span>
        <span class="k">return</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">child</span><span class="p">(</span><span class="n">name</span><span class="p">)</span> <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">subnames</span><span class="p">]</span>

    <span class="k">def</span> <span class="nf">walk</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">descend</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Yield myself, then each of my children, and each of those children&#39;s</span>
<span class="sd">        children in turn.</span>

<span class="sd">        The optional argument C{descend} is a predicate that takes a FilePath,</span>
<span class="sd">        and determines whether or not that FilePath is traversed/descended</span>
<span class="sd">        into.  It will be called with each path for which C{isdir} returns</span>
<span class="sd">        C{True}.  If C{descend} is not specified, all directories will be</span>
<span class="sd">        traversed (including symbolic links which refer to directories).</span>

<span class="sd">        @param descend: A one-argument callable that will return True for</span>
<span class="sd">            FilePaths that should be traversed, False otherwise.</span>

<span class="sd">        @return: a generator yielding FilePath-like objects.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">yield</span> <span class="bp">self</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">isdir</span><span class="p">():</span>
            <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">children</span><span class="p">():</span>
                <span class="c1"># we should first see if it&#39;s what we want, then we</span>
                <span class="c1"># can walk through the directory</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">descend</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">descend</span><span class="p">(</span><span class="n">c</span><span class="p">)):</span>
                    <span class="k">for</span> <span class="n">subc</span> <span class="ow">in</span> <span class="n">c</span><span class="o">.</span><span class="n">walk</span><span class="p">(</span><span class="n">descend</span><span class="p">):</span>
                        <span class="k">if</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">realpath</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">path</span><span class="p">)</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span>
                            <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">realpath</span><span class="p">(</span><span class="n">subc</span><span class="o">.</span><span class="n">path</span><span class="p">)):</span>
                            <span class="k">raise</span> <span class="n">LinkError</span><span class="p">(</span><span class="s2">&quot;Cycle in file graph.&quot;</span><span class="p">)</span>
                        <span class="k">yield</span> <span class="n">subc</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">yield</span> <span class="n">c</span>


    <span class="k">def</span> <span class="nf">sibling</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">path</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return a L{FilePath} with the same directory as this instance but with</span>
<span class="sd">        a basename of C{path}.</span>

<span class="sd">        @param path: The basename of the L{FilePath} to return.</span>
<span class="sd">        @type path: L{str}</span>

<span class="sd">        @return: The sibling path.</span>
<span class="sd">        @rtype: L{FilePath}</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">parent</span><span class="p">()</span><span class="o">.</span><span class="n">child</span><span class="p">(</span><span class="n">path</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">descendant</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">segments</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Retrieve a child or child&#39;s child of this path.</span>

<span class="sd">        @param segments: A sequence of path segments as L{str} instances.</span>

<span class="sd">        @return: A L{FilePath} constructed by looking up the C{segments[0]}</span>
<span class="sd">            child of this path, the C{segments[1]} child of that path, and so</span>
<span class="sd">            on.</span>

<span class="sd">        @since: 10.2</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">path</span> <span class="o">=</span> <span class="bp">self</span>
        <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">segments</span><span class="p">:</span>
            <span class="n">path</span> <span class="o">=</span> <span class="n">path</span><span class="o">.</span><span class="n">child</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">path</span>


    <span class="k">def</span> <span class="nf">segmentsFrom</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ancestor</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return a list of segments between a child and its ancestor.</span>

<span class="sd">        For example, in the case of a path X representing /a/b/c/d and a path Y</span>
<span class="sd">        representing /a/b, C{Y.segmentsFrom(X)} will return C{[&#39;c&#39;,</span>
<span class="sd">        &#39;d&#39;]}.</span>

<span class="sd">        @param ancestor: an instance of the same class as self, ostensibly an</span>
<span class="sd">        ancestor of self.</span>

<span class="sd">        @raise: ValueError if the &#39;ancestor&#39; parameter is not actually an</span>
<span class="sd">        ancestor, i.e. a path for /x/y/z is passed as an ancestor for /a/b/c/d.</span>

<span class="sd">        @return: a list of strs</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># this might be an unnecessarily inefficient implementation but it will</span>
        <span class="c1"># work on win32 and for zipfiles; later I will deterimine if the</span>
        <span class="c1"># obvious fast implemenation does the right thing too</span>
        <span class="n">f</span> <span class="o">=</span> <span class="bp">self</span>
        <span class="n">p</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="n">parent</span><span class="p">()</span>
        <span class="n">segments</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">while</span> <span class="n">f</span> <span class="o">!=</span> <span class="n">ancestor</span> <span class="ow">and</span> <span class="n">p</span> <span class="o">!=</span> <span class="n">f</span><span class="p">:</span>
            <span class="n">segments</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">f</span><span class="o">.</span><span class="n">basename</span><span class="p">()]</span>
            <span class="n">f</span> <span class="o">=</span> <span class="n">p</span>
            <span class="n">p</span> <span class="o">=</span> <span class="n">p</span><span class="o">.</span><span class="n">parent</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">f</span> <span class="o">==</span> <span class="n">ancestor</span> <span class="ow">and</span> <span class="n">segments</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">segments</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">%r</span><span class="s2"> not parent of </span><span class="si">%r</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">ancestor</span><span class="p">,</span> <span class="bp">self</span><span class="p">))</span>


    <span class="c1"># new in 8.0</span>
    <span class="k">def</span> <span class="nf">__hash__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Hash the same as another L{FilePath} with the same path as mine.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">hash</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">path</span><span class="p">))</span>


    <span class="c1"># pending deprecation in 8.0</span>
    <span class="k">def</span> <span class="nf">getmtime</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Deprecated.  Use getModificationTime instead.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">int</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">getModificationTime</span><span class="p">())</span>


    <span class="k">def</span> <span class="nf">getatime</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Deprecated.  Use getAccessTime instead.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">int</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">getAccessTime</span><span class="p">())</span>


    <span class="k">def</span> <span class="nf">getctime</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Deprecated.  Use getStatusChangeTime instead.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">int</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">getStatusChangeTime</span><span class="p">())</span>



<span class="k">class</span> <span class="nc">RWX</span><span class="p">(</span><span class="n">FancyEqMixin</span><span class="p">,</span> <span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A class representing read/write/execute permissions for a single user</span>
<span class="sd">    category (i.e. user/owner, group, or other/world).  Instantiate with</span>
<span class="sd">    three boolean values: readable? writable? executable?.</span>

<span class="sd">    @type read: C{bool}</span>
<span class="sd">    @ivar read: Whether permission to read is given</span>

<span class="sd">    @type write: C{bool}</span>
<span class="sd">    @ivar write: Whether permission to write is given</span>

<span class="sd">    @type execute: C{bool}</span>
<span class="sd">    @ivar execute: Whether permission to execute is given</span>

<span class="sd">    @since: 11.1</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">compareAttributes</span> <span class="o">=</span> <span class="p">(</span><span class="s1">&#39;read&#39;</span><span class="p">,</span> <span class="s1">&#39;write&#39;</span><span class="p">,</span> <span class="s1">&#39;execute&#39;</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">readable</span><span class="p">,</span> <span class="n">writable</span><span class="p">,</span> <span class="n">executable</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">read</span> <span class="o">=</span> <span class="n">readable</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">write</span> <span class="o">=</span> <span class="n">writable</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">execute</span> <span class="o">=</span> <span class="n">executable</span>


    <span class="k">def</span> <span class="nf">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="s2">&quot;RWX(read=</span><span class="si">%s</span><span class="s2">, write=</span><span class="si">%s</span><span class="s2">, execute=</span><span class="si">%s</span><span class="s2">)&quot;</span> <span class="o">%</span> <span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">read</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">write</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">execute</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">shorthand</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns a short string representing the permission bits.  Looks like</span>
<span class="sd">        part of what is printed by command line utilities such as &#39;ls -l&#39;</span>
<span class="sd">        (e.g. &#39;rwx&#39;)</span>

<span class="sd">        @return: The shorthand string.</span>
<span class="sd">        @rtype: L{str}</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">returnval</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;r&#39;</span><span class="p">,</span> <span class="s1">&#39;w&#39;</span><span class="p">,</span> <span class="s1">&#39;x&#39;</span><span class="p">]</span>
        <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">val</span> <span class="ow">in</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">read</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">write</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">execute</span><span class="p">):</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">val</span><span class="p">:</span>
                <span class="n">returnval</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;-&#39;</span>
            <span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="k">return</span> <span class="s1">&#39;&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">returnval</span><span class="p">)</span>



<span class="k">class</span> <span class="nc">Permissions</span><span class="p">(</span><span class="n">FancyEqMixin</span><span class="p">,</span> <span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A class representing read/write/execute permissions.  Instantiate with any</span>
<span class="sd">    portion of the file&#39;s mode that includes the permission bits.</span>

<span class="sd">    @type user: L{RWX}</span>
<span class="sd">    @ivar user: User/Owner permissions</span>

<span class="sd">    @type group: L{RWX}</span>
<span class="sd">    @ivar group: Group permissions</span>

<span class="sd">    @type other: L{RWX}</span>
<span class="sd">    @ivar other: Other/World permissions</span>

<span class="sd">    @since: 11.1</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">compareAttributes</span> <span class="o">=</span> <span class="p">(</span><span class="s1">&#39;user&#39;</span><span class="p">,</span> <span class="s1">&#39;group&#39;</span><span class="p">,</span> <span class="s1">&#39;other&#39;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">statModeInt</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">user</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">group</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">other</span> <span class="o">=</span> <span class="p">(</span>
            <span class="p">[</span><span class="n">RWX</span><span class="p">(</span><span class="o">*</span><span class="p">[</span><span class="n">statModeInt</span> <span class="o">&amp;</span> <span class="n">bit</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="k">for</span> <span class="n">bit</span> <span class="ow">in</span> <span class="n">bitGroup</span><span class="p">])</span> <span class="k">for</span> <span class="n">bitGroup</span> <span class="ow">in</span>
             <span class="p">[[</span><span class="n">S_IRUSR</span><span class="p">,</span> <span class="n">S_IWUSR</span><span class="p">,</span> <span class="n">S_IXUSR</span><span class="p">],</span>
              <span class="p">[</span><span class="n">S_IRGRP</span><span class="p">,</span> <span class="n">S_IWGRP</span><span class="p">,</span> <span class="n">S_IXGRP</span><span class="p">],</span>
              <span class="p">[</span><span class="n">S_IROTH</span><span class="p">,</span> <span class="n">S_IWOTH</span><span class="p">,</span> <span class="n">S_IXOTH</span><span class="p">]]]</span>
        <span class="p">)</span>


    <span class="k">def</span> <span class="nf">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="s2">&quot;[</span><span class="si">%s</span><span class="s2"> | </span><span class="si">%s</span><span class="s2"> | </span><span class="si">%s</span><span class="s2">]&quot;</span> <span class="o">%</span> <span class="p">(</span>
            <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">user</span><span class="p">),</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">group</span><span class="p">),</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">other</span><span class="p">))</span>


    <span class="k">def</span> <span class="nf">shorthand</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns a short string representing the permission bits.  Looks like</span>
<span class="sd">        what is printed by command line utilities such as &#39;ls -l&#39;</span>
<span class="sd">        (e.g. &#39;rwx-wx--x&#39;)</span>

<span class="sd">        @return: The shorthand string.</span>
<span class="sd">        @rtype: L{str}</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="s2">&quot;&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span>
            <span class="p">[</span><span class="n">x</span><span class="o">.</span><span class="n">shorthand</span><span class="p">()</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">user</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">group</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">other</span><span class="p">)])</span>


<span class="k">class</span> <span class="nc">_SpecialNoValue</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    An object that represents &#39;no value&#39;, to be used in deprecating statinfo.</span>

<span class="sd">    Please remove once statinfo is removed.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">pass</span>



<span class="k">def</span> <span class="nf">_asFilesystemBytes</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="n">encoding</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Return C{path} as a string of L{bytes} suitable for use on this system&#39;s</span>
<span class="sd">    filesystem.</span>

<span class="sd">    @param path: The path to be made suitable.</span>
<span class="sd">    @type path: L{bytes} or L{unicode}</span>
<span class="sd">    @param encoding: The encoding to use if coercing to L{bytes}. If none is</span>
<span class="sd">        given, L{sys.getfilesystemencoding} is used.</span>

<span class="sd">    @return: L{bytes}</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">path</span><span class="p">)</span> <span class="o">==</span> <span class="nb">bytes</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">path</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">encoding</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">encoding</span> <span class="o">=</span> <span class="n">sys</span><span class="o">.</span><span class="n">getfilesystemencoding</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">path</span><span class="o">.</span><span class="n">encode</span><span class="p">(</span><span class="n">encoding</span><span class="p">)</span>



<span class="k">def</span> <span class="nf">_asFilesystemText</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="n">encoding</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Return C{path} as a string of L{unicode} suitable for use on this system&#39;s</span>
<span class="sd">    filesystem.</span>

<span class="sd">    @param path: The path to be made suitable.</span>
<span class="sd">    @type path: L{bytes} or L{unicode}</span>

<span class="sd">    @param encoding: The encoding to use if coercing to L{unicode}. If none</span>
<span class="sd">        is given, L{sys.getfilesystemencoding} is used.</span>

<span class="sd">    @return: L{unicode}</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">path</span><span class="p">)</span> <span class="o">==</span> <span class="n">unicode</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">path</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">encoding</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">encoding</span> <span class="o">=</span> <span class="n">sys</span><span class="o">.</span><span class="n">getfilesystemencoding</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">path</span><span class="o">.</span><span class="n">decode</span><span class="p">(</span><span class="n">encoding</span><span class="p">)</span>



<span class="k">def</span> <span class="nf">_coerceToFilesystemEncoding</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="n">newpath</span><span class="p">,</span> <span class="n">encoding</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Return a C{newpath} that is suitable for joining to C{path}.</span>

<span class="sd">    @param path: The path that it should be suitable for joining to.</span>
<span class="sd">    @param newpath: The new portion of the path to be coerced if needed.</span>
<span class="sd">    @param encoding: If coerced, the encoding that will be used.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">path</span><span class="p">)</span> <span class="o">==</span> <span class="nb">bytes</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_asFilesystemBytes</span><span class="p">(</span><span class="n">newpath</span><span class="p">,</span> <span class="n">encoding</span><span class="o">=</span><span class="n">encoding</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_asFilesystemText</span><span class="p">(</span><span class="n">newpath</span><span class="p">,</span> <span class="n">encoding</span><span class="o">=</span><span class="n">encoding</span><span class="p">)</span>



<span class="nd">@comparable</span>
<span class="nd">@implementer</span><span class="p">(</span><span class="n">IFilePath</span><span class="p">)</span>
<span class="k">class</span> <span class="nc">FilePath</span><span class="p">(</span><span class="n">AbstractFilePath</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    I am a path on the filesystem that only permits &#39;downwards&#39; access.</span>

<span class="sd">    Instantiate me with a pathname (for example,</span>
<span class="sd">    FilePath(&#39;/home/myuser/public_html&#39;)) and I will attempt to only provide</span>
<span class="sd">    access to files which reside inside that path.  I may be a path to a file,</span>
<span class="sd">    a directory, or a file which does not exist.</span>

<span class="sd">    The correct way to use me is to instantiate me, and then do ALL filesystem</span>
<span class="sd">    access through me.  In other words, do not import the &#39;os&#39; module; if you</span>
<span class="sd">    need to open a file, call my &#39;open&#39; method.  If you need to list a</span>
<span class="sd">    directory, call my &#39;path&#39; method.</span>

<span class="sd">    Even if you pass me a relative path, I will convert that to an absolute</span>
<span class="sd">    path internally.</span>

<span class="sd">    Note: although time-related methods do return floating-point results, they</span>
<span class="sd">    may still be only second resolution depending on the platform and the last</span>
<span class="sd">    value passed to L{os.stat_float_times}.  If you want greater-than-second</span>
<span class="sd">    precision, call C{os.stat_float_times(True)}, or use Python 2.5.</span>
<span class="sd">    Greater-than-second precision is only available in Windows on Python2.5 and</span>
<span class="sd">    later.</span>

<span class="sd">    The type of C{path} when instantiating decides the mode of the L{FilePath}.</span>
<span class="sd">    That is, C{FilePath(b&quot;/&quot;)} will return a L{bytes} mode L{FilePath}, and</span>
<span class="sd">    C{FilePath(u&quot;/&quot;)} will return a L{unicode} mode L{FilePath}.</span>
<span class="sd">    C{FilePath(&quot;/&quot;)} will return a L{bytes} mode L{FilePath} on Python 2, and a</span>
<span class="sd">    L{unicode} mode L{FilePath} on Python 3.</span>

<span class="sd">    Methods that return a new L{FilePath} use the type of the given subpath to</span>
<span class="sd">    decide its mode. For example, C{FilePath(b&quot;/&quot;).child(u&quot;tmp&quot;)} will return a</span>
<span class="sd">    L{unicode} mode L{FilePath}.</span>

<span class="sd">    @type alwaysCreate: L{bool}</span>
<span class="sd">    @ivar alwaysCreate: When opening this file, only succeed if the file does</span>
<span class="sd">        not already exist.</span>

<span class="sd">    @type path: L{bytes} or L{unicode}</span>
<span class="sd">    @ivar path: The path from which &#39;downward&#39; traversal is permitted.</span>

<span class="sd">    @ivar statinfo: (WARNING: statinfo is deprecated as of Twisted 15.0.0 and</span>
<span class="sd">        will become a private attribute)</span>
<span class="sd">        The currently cached status information about the file on</span>
<span class="sd">        the filesystem that this L{FilePath} points to.  This attribute is</span>
<span class="sd">        L{None} if the file is in an indeterminate state (either this</span>
<span class="sd">        L{FilePath} has not yet had cause to call C{stat()} yet or</span>
<span class="sd">        L{FilePath.changed} indicated that new information is required), 0 if</span>
<span class="sd">        C{stat()} was called and returned an error (i.e. the path did not exist</span>
<span class="sd">        when C{stat()} was called), or a C{stat_result} object that describes</span>
<span class="sd">        the last known status of the underlying file (or directory, as the case</span>
<span class="sd">        may be).  Trust me when I tell you that you do not want to use this</span>
<span class="sd">        attribute.  Instead, use the methods on L{FilePath} which give you</span>
<span class="sd">        information about it, like C{getsize()}, C{isdir()},</span>
<span class="sd">        C{getModificationTime()}, and so on.</span>
<span class="sd">    @type statinfo: L{int} or L{None} or L{os.stat_result}</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">_statinfo</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="n">path</span> <span class="o">=</span> <span class="kc">None</span>


    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">path</span><span class="p">,</span> <span class="n">alwaysCreate</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Convert a path string to an absolute path if necessary and initialize</span>
<span class="sd">        the L{FilePath} with the result.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">path</span> <span class="o">=</span> <span class="n">abspath</span><span class="p">(</span><span class="n">path</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">alwaysCreate</span> <span class="o">=</span> <span class="n">alwaysCreate</span>


    <span class="k">def</span> <span class="nf">__getstate__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Support serialization by discarding cached L{os.stat} results and</span>
<span class="sd">        returning everything else.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">d</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__dict__</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="k">if</span> <span class="s1">&#39;_statinfo&#39;</span> <span class="ow">in</span> <span class="n">d</span><span class="p">:</span>
            <span class="k">del</span> <span class="n">d</span><span class="p">[</span><span class="s1">&#39;_statinfo&#39;</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">d</span>


    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">sep</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return a filesystem separator.</span>

<span class="sd">        @return: The native filesystem separator.</span>
<span class="sd">        @returntype: The same type as C{self.path}.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_coerceToFilesystemEncoding</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">path</span><span class="p">,</span> <span class="n">os</span><span class="o">.</span><span class="n">sep</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">_asBytesPath</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">encoding</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the path of this L{FilePath} as bytes.</span>

<span class="sd">        @param encoding: The encoding to use if coercing to L{bytes}. If none is</span>
<span class="sd">            given, L{sys.getfilesystemencoding} is used.</span>

<span class="sd">        @return: L{bytes}</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_asFilesystemBytes</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">path</span><span class="p">,</span> <span class="n">encoding</span><span class="o">=</span><span class="n">encoding</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">_asTextPath</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">encoding</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the path of this L{FilePath} as text.</span>

<span class="sd">        @param encoding: The encoding to use if coercing to L{unicode}. If none</span>
<span class="sd">            is given, L{sys.getfilesystemencoding} is used.</span>

<span class="sd">        @return: L{unicode}</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_asFilesystemText</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">path</span><span class="p">,</span> <span class="n">encoding</span><span class="o">=</span><span class="n">encoding</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">asBytesMode</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">encoding</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return this L{FilePath} in L{bytes}-mode.</span>

<span class="sd">        @param encoding: The encoding to use if coercing to L{bytes}. If none is</span>
<span class="sd">            given, L{sys.getfilesystemencoding} is used.</span>

<span class="sd">        @return: L{bytes} mode L{FilePath}</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">path</span><span class="p">)</span> <span class="o">==</span> <span class="n">unicode</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">clonePath</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_asBytesPath</span><span class="p">(</span><span class="n">encoding</span><span class="o">=</span><span class="n">encoding</span><span class="p">))</span>
        <span class="k">return</span> <span class="bp">self</span>


    <span class="k">def</span> <span class="nf">asTextMode</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">encoding</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return this L{FilePath} in L{unicode}-mode.</span>

<span class="sd">        @param encoding: The encoding to use if coercing to L{unicode}. If none</span>
<span class="sd">            is given, L{sys.getfilesystemencoding} is used.</span>

<span class="sd">        @return: L{unicode} mode L{FilePath}</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">path</span><span class="p">)</span> <span class="o">==</span> <span class="nb">bytes</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">clonePath</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_asTextPath</span><span class="p">(</span><span class="n">encoding</span><span class="o">=</span><span class="n">encoding</span><span class="p">))</span>
        <span class="k">return</span> <span class="bp">self</span>


    <span class="k">def</span> <span class="nf">_getPathAsSameTypeAs</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pattern</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        If C{pattern} is C{bytes}, return L{FilePath.path} as L{bytes}.</span>
<span class="sd">        Otherwise, return L{FilePath.path} as L{unicode}.</span>

<span class="sd">        @param pattern: The new element of the path that L{FilePath.path} may</span>
<span class="sd">            need to be coerced to match.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">pattern</span><span class="p">)</span> <span class="o">==</span> <span class="nb">bytes</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_asBytesPath</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_asTextPath</span><span class="p">()</span>


    <span class="k">def</span> <span class="nf">child</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">path</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Create and return a new L{FilePath} representing a path contained by</span>
<span class="sd">        C{self}.</span>

<span class="sd">        @param path: The base name of the new L{FilePath}.  If this contains</span>
<span class="sd">            directory separators or parent references it will be rejected.</span>
<span class="sd">        @type path: L{bytes} or L{unicode}</span>

<span class="sd">        @raise InsecurePath: If the result of combining this path with C{path}</span>
<span class="sd">            would result in a path which is not a direct child of this path.</span>

<span class="sd">        @return: The child path.</span>
<span class="sd">        @rtype: L{FilePath} with a mode equal to the type of C{path}.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">colon</span> <span class="o">=</span> <span class="n">_coerceToFilesystemEncoding</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="s2">&quot;:&quot;</span><span class="p">)</span>
        <span class="n">sep</span> <span class="o">=</span>  <span class="n">_coerceToFilesystemEncoding</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="n">os</span><span class="o">.</span><span class="n">sep</span><span class="p">)</span>
        <span class="n">ourPath</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_getPathAsSameTypeAs</span><span class="p">(</span><span class="n">path</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">platform</span><span class="o">.</span><span class="n">isWindows</span><span class="p">()</span> <span class="ow">and</span> <span class="n">path</span><span class="o">.</span><span class="n">count</span><span class="p">(</span><span class="n">colon</span><span class="p">):</span>
            <span class="c1"># Catch paths like C:blah that don&#39;t have a slash</span>
            <span class="k">raise</span> <span class="n">InsecurePath</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">%r</span><span class="s2"> contains a colon.&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">path</span><span class="p">,))</span>

        <span class="n">norm</span> <span class="o">=</span> <span class="n">normpath</span><span class="p">(</span><span class="n">path</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">sep</span> <span class="ow">in</span> <span class="n">norm</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">InsecurePath</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">%r</span><span class="s2"> contains one or more directory separators&quot;</span> <span class="o">%</span>
                               <span class="p">(</span><span class="n">path</span><span class="p">,))</span>

        <span class="n">newpath</span> <span class="o">=</span> <span class="n">abspath</span><span class="p">(</span><span class="n">joinpath</span><span class="p">(</span><span class="n">ourPath</span><span class="p">,</span> <span class="n">norm</span><span class="p">))</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">newpath</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="n">ourPath</span><span class="p">):</span>
            <span class="k">raise</span> <span class="n">InsecurePath</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">%r</span><span class="s2"> is not a child of </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span>
                               <span class="p">(</span><span class="n">newpath</span><span class="p">,</span> <span class="n">ourPath</span><span class="p">))</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">clonePath</span><span class="p">(</span><span class="n">newpath</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">preauthChild</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">path</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Use me if C{path} might have slashes in it, but you know they&#39;re safe.</span>

<span class="sd">        @param path: A relative path (ie, a path not starting with C{&quot;/&quot;})</span>
<span class="sd">            which will be interpreted as a child or descendant of this path.</span>
<span class="sd">        @type path: L{bytes} or L{unicode}</span>

<span class="sd">        @return: The child path.</span>
<span class="sd">        @rtype: L{FilePath} with a mode equal to the type of C{path}.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">ourPath</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_getPathAsSameTypeAs</span><span class="p">(</span><span class="n">path</span><span class="p">)</span>

        <span class="n">newpath</span> <span class="o">=</span> <span class="n">abspath</span><span class="p">(</span><span class="n">joinpath</span><span class="p">(</span><span class="n">ourPath</span><span class="p">,</span> <span class="n">normpath</span><span class="p">(</span><span class="n">path</span><span class="p">)))</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">newpath</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="n">ourPath</span><span class="p">):</span>
            <span class="k">raise</span> <span class="n">InsecurePath</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">%s</span><span class="s2"> is not a child of </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span>
                               <span class="p">(</span><span class="n">newpath</span><span class="p">,</span> <span class="n">ourPath</span><span class="p">))</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">clonePath</span><span class="p">(</span><span class="n">newpath</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">childSearchPreauth</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">paths</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return my first existing child with a name in C{paths}.</span>

<span class="sd">        C{paths} is expected to be a list of *pre-secured* path fragments;</span>
<span class="sd">        in most cases this will be specified by a system administrator and not</span>
<span class="sd">        an arbitrary user.</span>

<span class="sd">        If no appropriately-named children exist, this will return L{None}.</span>

<span class="sd">        @return: L{None} or the child path.</span>
<span class="sd">        @rtype: L{None} or L{FilePath}</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">child</span> <span class="ow">in</span> <span class="n">paths</span><span class="p">:</span>
            <span class="n">p</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_getPathAsSameTypeAs</span><span class="p">(</span><span class="n">child</span><span class="p">)</span>
            <span class="n">jp</span> <span class="o">=</span> <span class="n">joinpath</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">child</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">exists</span><span class="p">(</span><span class="n">jp</span><span class="p">):</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">clonePath</span><span class="p">(</span><span class="n">jp</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">siblingExtensionSearch</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">exts</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Attempt to return a path with my name, given multiple possible</span>
<span class="sd">        extensions.</span>

<span class="sd">        Each extension in C{exts} will be tested and the first path which</span>
<span class="sd">        exists will be returned.  If no path exists, L{None} will be returned.</span>
<span class="sd">        If C{&#39;&#39;} is in C{exts}, then if the file referred to by this path</span>
<span class="sd">        exists, C{self} will be returned.</span>

<span class="sd">        The extension &#39;*&#39; has a magic meaning, which means &quot;any path that</span>
<span class="sd">        begins with C{self.path + &#39;.&#39;} is acceptable&quot;.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">ext</span> <span class="ow">in</span> <span class="n">exts</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">ext</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">exists</span><span class="p">():</span>
                <span class="k">return</span> <span class="bp">self</span>

            <span class="n">p</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_getPathAsSameTypeAs</span><span class="p">(</span><span class="n">ext</span><span class="p">)</span>
            <span class="n">star</span> <span class="o">=</span> <span class="n">_coerceToFilesystemEncoding</span><span class="p">(</span><span class="n">ext</span><span class="p">,</span> <span class="s2">&quot;*&quot;</span><span class="p">)</span>
            <span class="n">dot</span> <span class="o">=</span> <span class="n">_coerceToFilesystemEncoding</span><span class="p">(</span><span class="n">ext</span><span class="p">,</span> <span class="s2">&quot;.&quot;</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">ext</span> <span class="o">==</span> <span class="n">star</span><span class="p">:</span>
                <span class="n">basedot</span> <span class="o">=</span> <span class="n">basename</span><span class="p">(</span><span class="n">p</span><span class="p">)</span> <span class="o">+</span> <span class="n">dot</span>
                <span class="k">for</span> <span class="n">fn</span> <span class="ow">in</span> <span class="n">listdir</span><span class="p">(</span><span class="n">dirname</span><span class="p">(</span><span class="n">p</span><span class="p">)):</span>
                    <span class="k">if</span> <span class="n">fn</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="n">basedot</span><span class="p">):</span>
                        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">clonePath</span><span class="p">(</span><span class="n">joinpath</span><span class="p">(</span><span class="n">dirname</span><span class="p">(</span><span class="n">p</span><span class="p">),</span> <span class="n">fn</span><span class="p">))</span>
            <span class="n">p2</span> <span class="o">=</span> <span class="n">p</span> <span class="o">+</span> <span class="n">ext</span>
            <span class="k">if</span> <span class="n">exists</span><span class="p">(</span><span class="n">p2</span><span class="p">):</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">clonePath</span><span class="p">(</span><span class="n">p2</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">realpath</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the absolute target as a L{FilePath} if self is a link, self</span>
<span class="sd">        otherwise.</span>

<span class="sd">        The absolute link is the ultimate file or directory the</span>
<span class="sd">        link refers to (for instance, if the link refers to another link, and</span>
<span class="sd">        another...).  If the filesystem does not support symlinks, or</span>
<span class="sd">        if the link is cyclical, raises a L{LinkError}.</span>

<span class="sd">        Behaves like L{os.path.realpath} in that it does not resolve link</span>
<span class="sd">        names in the middle (ex. /x/y/z, y is a link to w - realpath on z</span>
<span class="sd">        will return /x/y/z, not /x/w/z).</span>

<span class="sd">        @return: L{FilePath} of the target path.</span>
<span class="sd">        @rtype: L{FilePath}</span>
<span class="sd">        @raises LinkError: if links are not supported or links are cyclical.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">islink</span><span class="p">():</span>
            <span class="n">result</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">realpath</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">path</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">result</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">path</span><span class="p">:</span>
                <span class="k">raise</span> <span class="n">LinkError</span><span class="p">(</span><span class="s2">&quot;Cyclical link - will loop forever&quot;</span><span class="p">)</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">clonePath</span><span class="p">(</span><span class="n">result</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span>


    <span class="k">def</span> <span class="nf">siblingExtension</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ext</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Attempt to return a path with my name, given the extension at C{ext}.</span>

<span class="sd">        @param ext: File-extension to search for.</span>
<span class="sd">        @type ext: L{bytes} or L{unicode}</span>

<span class="sd">        @return: The sibling path.</span>
<span class="sd">        @rtype: L{FilePath} with the same mode as the type of C{ext}.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">ourPath</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_getPathAsSameTypeAs</span><span class="p">(</span><span class="n">ext</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">clonePath</span><span class="p">(</span><span class="n">ourPath</span> <span class="o">+</span> <span class="n">ext</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">linkTo</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">linkFilePath</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Creates a symlink to self to at the path in the L{FilePath}</span>
<span class="sd">        C{linkFilePath}.</span>

<span class="sd">        Only works on posix systems due to its dependence on</span>
<span class="sd">        L{os.symlink}.  Propagates L{OSError}s up from L{os.symlink} if</span>
<span class="sd">        C{linkFilePath.parent()} does not exist, or C{linkFilePath} already</span>
<span class="sd">        exists.</span>

<span class="sd">        @param linkFilePath: a FilePath representing the link to be created.</span>
<span class="sd">        @type linkFilePath: L{FilePath}</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">os</span><span class="o">.</span><span class="n">symlink</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">path</span><span class="p">,</span> <span class="n">linkFilePath</span><span class="o">.</span><span class="n">path</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">open</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;r&#39;</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Open this file using C{mode} or for writing if C{alwaysCreate} is</span>
<span class="sd">        C{True}.</span>

<span class="sd">        In all cases the file is opened in binary mode, so it is not necessary</span>
<span class="sd">        to include C{&quot;b&quot;} in C{mode}.</span>

<span class="sd">        @param mode: The mode to open the file in.  Default is C{&quot;r&quot;}.</span>
<span class="sd">        @type mode: L{str}</span>
<span class="sd">        @raises AssertionError: If C{&quot;a&quot;} is included in the mode and</span>
<span class="sd">            C{alwaysCreate} is C{True}.</span>
<span class="sd">        @rtype: L{file}</span>
<span class="sd">        @return: An open L{file} object.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">alwaysCreate</span><span class="p">:</span>
            <span class="k">assert</span> <span class="s1">&#39;a&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">mode</span><span class="p">,</span> <span class="p">(</span><span class="s2">&quot;Appending not supported when &quot;</span>
                                     <span class="s2">&quot;alwaysCreate == True&quot;</span><span class="p">)</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">create</span><span class="p">()</span>
        <span class="c1"># This hack is necessary because of a bug in Python 2.7 on Windows:</span>
        <span class="c1"># http://bugs.python.org/issue7686</span>
        <span class="n">mode</span> <span class="o">=</span> <span class="n">mode</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s1">&#39;b&#39;</span><span class="p">,</span> <span class="s1">&#39;&#39;</span><span class="p">)</span>
        <span class="k">return</span> <span class="nb">open</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">path</span><span class="p">,</span> <span class="n">mode</span> <span class="o">+</span> <span class="s1">&#39;b&#39;</span><span class="p">)</span>

    <span class="c1"># stat methods below</span>

    <span class="k">def</span> <span class="nf">restat</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">reraise</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Re-calculate cached effects of &#39;stat&#39;.  To refresh information on this</span>
<span class="sd">        path after you know the filesystem may have changed, call this method.</span>

<span class="sd">        @param reraise: a boolean.  If true, re-raise exceptions from</span>
<span class="sd">            L{os.stat}; otherwise, mark this path as not existing, and remove</span>
<span class="sd">            any cached stat information.</span>

<span class="sd">        @raise Exception: If C{reraise} is C{True} and an exception occurs</span>
<span class="sd">            while reloading metadata.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_statinfo</span> <span class="o">=</span> <span class="n">stat</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">path</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">OSError</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_statinfo</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="k">if</span> <span class="n">reraise</span><span class="p">:</span>
                <span class="k">raise</span>


    <span class="k">def</span> <span class="nf">changed</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Clear any cached information about the state of this path on disk.</span>

<span class="sd">        @since: 10.1.0</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_statinfo</span> <span class="o">=</span> <span class="kc">None</span>


    <span class="k">def</span> <span class="nf">chmod</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">mode</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Changes the permissions on self, if possible.  Propagates errors from</span>
<span class="sd">        L{os.chmod} up.</span>

<span class="sd">        @param mode: integer representing the new permissions desired (same as</span>
<span class="sd">            the command line chmod)</span>
<span class="sd">        @type mode: L{int}</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">os</span><span class="o">.</span><span class="n">chmod</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">path</span><span class="p">,</span> <span class="n">mode</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">getsize</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Retrieve the size of this file in bytes.</span>

<span class="sd">        @return: The size of the file at this file path in bytes.</span>
<span class="sd">        @raise Exception: if the size cannot be obtained.</span>
<span class="sd">        @rtype: L{int}</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">st</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_statinfo</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">st</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">restat</span><span class="p">()</span>
            <span class="n">st</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_statinfo</span>
        <span class="k">return</span> <span class="n">st</span><span class="o">.</span><span class="n">st_size</span>


    <span class="k">def</span> <span class="nf">getModificationTime</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Retrieve the time of last access from this file.</span>

<span class="sd">        @return: a number of seconds from the epoch.</span>
<span class="sd">        @rtype: L{float}</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">st</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_statinfo</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">st</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">restat</span><span class="p">()</span>
            <span class="n">st</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_statinfo</span>
        <span class="k">return</span> <span class="nb">float</span><span class="p">(</span><span class="n">st</span><span class="o">.</span><span class="n">st_mtime</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">getStatusChangeTime</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Retrieve the time of the last status change for this file.</span>

<span class="sd">        @return: a number of seconds from the epoch.</span>
<span class="sd">        @rtype: L{float}</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">st</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_statinfo</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">st</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">restat</span><span class="p">()</span>
            <span class="n">st</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_statinfo</span>
        <span class="k">return</span> <span class="nb">float</span><span class="p">(</span><span class="n">st</span><span class="o">.</span><span class="n">st_ctime</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">getAccessTime</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Retrieve the time that this file was last accessed.</span>

<span class="sd">        @return: a number of seconds from the epoch.</span>
<span class="sd">        @rtype: L{float}</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">st</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_statinfo</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">st</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">restat</span><span class="p">()</span>
            <span class="n">st</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_statinfo</span>
        <span class="k">return</span> <span class="nb">float</span><span class="p">(</span><span class="n">st</span><span class="o">.</span><span class="n">st_atime</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">getInodeNumber</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Retrieve the file serial number, also called inode number, which</span>
<span class="sd">        distinguishes this file from all other files on the same device.</span>

<span class="sd">        @raise NotImplementedError: if the platform is Windows, since the</span>
<span class="sd">            inode number would be a dummy value for all files in Windows</span>
<span class="sd">        @return: a number representing the file serial number</span>
<span class="sd">        @rtype: L{int}</span>
<span class="sd">        @since: 11.0</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">platform</span><span class="o">.</span><span class="n">isWindows</span><span class="p">():</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span>

        <span class="n">st</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_statinfo</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">st</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">restat</span><span class="p">()</span>
            <span class="n">st</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_statinfo</span>
        <span class="k">return</span> <span class="n">st</span><span class="o">.</span><span class="n">st_ino</span>


    <span class="k">def</span> <span class="nf">getDevice</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Retrieves the device containing the file.  The inode number and device</span>
<span class="sd">        number together uniquely identify the file, but the device number is</span>
<span class="sd">        not necessarily consistent across reboots or system crashes.</span>

<span class="sd">        @raise NotImplementedError: if the platform is Windows, since the</span>
<span class="sd">            device number would be 0 for all partitions on a Windows platform</span>

<span class="sd">        @return: a number representing the device</span>
<span class="sd">        @rtype: L{int}</span>

<span class="sd">        @since: 11.0</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">platform</span><span class="o">.</span><span class="n">isWindows</span><span class="p">():</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span>

        <span class="n">st</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_statinfo</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">st</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">restat</span><span class="p">()</span>
            <span class="n">st</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_statinfo</span>
        <span class="k">return</span> <span class="n">st</span><span class="o">.</span><span class="n">st_dev</span>


    <span class="k">def</span> <span class="nf">getNumberOfHardLinks</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Retrieves the number of hard links to the file.</span>

<span class="sd">        This count keeps track of how many directories have entries for this</span>
<span class="sd">        file. If the count is ever decremented to zero then the file itself is</span>
<span class="sd">        discarded as soon as no process still holds it open.  Symbolic links</span>
<span class="sd">        are not counted in the total.</span>

<span class="sd">        @raise NotImplementedError: if the platform is Windows, since Windows</span>
<span class="sd">            doesn&#39;t maintain a link count for directories, and L{os.stat} does</span>
<span class="sd">            not set C{st_nlink} on Windows anyway.</span>
<span class="sd">        @return: the number of hard links to the file</span>
<span class="sd">        @rtype: L{int}</span>
<span class="sd">        @since: 11.0</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">platform</span><span class="o">.</span><span class="n">isWindows</span><span class="p">():</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span>

        <span class="n">st</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_statinfo</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">st</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">restat</span><span class="p">()</span>
            <span class="n">st</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_statinfo</span>
        <span class="k">return</span> <span class="n">st</span><span class="o">.</span><span class="n">st_nlink</span>


    <span class="k">def</span> <span class="nf">getUserID</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the user ID of the file&#39;s owner.</span>

<span class="sd">        @raise NotImplementedError: if the platform is Windows, since the UID</span>
<span class="sd">            is always 0 on Windows</span>
<span class="sd">        @return: the user ID of the file&#39;s owner</span>
<span class="sd">        @rtype: L{int}</span>
<span class="sd">        @since: 11.0</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">platform</span><span class="o">.</span><span class="n">isWindows</span><span class="p">():</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span>

        <span class="n">st</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_statinfo</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">st</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">restat</span><span class="p">()</span>
            <span class="n">st</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_statinfo</span>
        <span class="k">return</span> <span class="n">st</span><span class="o">.</span><span class="n">st_uid</span>


    <span class="k">def</span> <span class="nf">getGroupID</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the group ID of the file.</span>

<span class="sd">        @raise NotImplementedError: if the platform is Windows, since the GID</span>
<span class="sd">            is always 0 on windows</span>
<span class="sd">        @return: the group ID of the file</span>
<span class="sd">        @rtype: L{int}</span>
<span class="sd">        @since: 11.0</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">platform</span><span class="o">.</span><span class="n">isWindows</span><span class="p">():</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span>

        <span class="n">st</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_statinfo</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">st</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">restat</span><span class="p">()</span>
            <span class="n">st</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_statinfo</span>
        <span class="k">return</span> <span class="n">st</span><span class="o">.</span><span class="n">st_gid</span>


    <span class="k">def</span> <span class="nf">getPermissions</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the permissions of the file.  Should also work on Windows,</span>
<span class="sd">        however, those permissions may not be what is expected in Windows.</span>

<span class="sd">        @return: the permissions for the file</span>
<span class="sd">        @rtype: L{Permissions}</span>
<span class="sd">        @since: 11.1</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">st</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_statinfo</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">st</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">restat</span><span class="p">()</span>
            <span class="n">st</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_statinfo</span>
        <span class="k">return</span> <span class="n">Permissions</span><span class="p">(</span><span class="n">S_IMODE</span><span class="p">(</span><span class="n">st</span><span class="o">.</span><span class="n">st_mode</span><span class="p">))</span>


    <span class="k">def</span> <span class="nf">exists</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Check if this L{FilePath} exists.</span>

<span class="sd">        @return: C{True} if the stats of C{path} can be retrieved successfully,</span>
<span class="sd">            C{False} in the other cases.</span>
<span class="sd">        @rtype: L{bool}</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_statinfo</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">True</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">restat</span><span class="p">(</span><span class="kc">False</span><span class="p">)</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_statinfo</span><span class="p">:</span>
                <span class="k">return</span> <span class="kc">True</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="kc">False</span>


    <span class="k">def</span> <span class="nf">isdir</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Check if this L{FilePath} refers to a directory.</span>

<span class="sd">        @return: C{True} if this L{FilePath} refers to a directory, C{False}</span>
<span class="sd">            otherwise.</span>
<span class="sd">        @rtype: L{bool}</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">st</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_statinfo</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">st</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">restat</span><span class="p">(</span><span class="kc">False</span><span class="p">)</span>
            <span class="n">st</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_statinfo</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">st</span><span class="p">:</span>
                <span class="k">return</span> <span class="kc">False</span>
        <span class="k">return</span> <span class="n">S_ISDIR</span><span class="p">(</span><span class="n">st</span><span class="o">.</span><span class="n">st_mode</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">isfile</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Check if this file path refers to a regular file.</span>

<span class="sd">        @return: C{True} if this L{FilePath} points to a regular file (not a</span>
<span class="sd">            directory, socket, named pipe, etc), C{False} otherwise.</span>
<span class="sd">        @rtype: L{bool}</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">st</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_statinfo</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">st</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">restat</span><span class="p">(</span><span class="kc">False</span><span class="p">)</span>
            <span class="n">st</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_statinfo</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">st</span><span class="p">:</span>
                <span class="k">return</span> <span class="kc">False</span>
        <span class="k">return</span> <span class="n">S_ISREG</span><span class="p">(</span><span class="n">st</span><span class="o">.</span><span class="n">st_mode</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">isBlockDevice</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns whether the underlying path is a block device.</span>

<span class="sd">        @return: C{True} if it is a block device, C{False} otherwise</span>
<span class="sd">        @rtype: L{bool}</span>
<span class="sd">        @since: 11.1</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">st</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_statinfo</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">st</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">restat</span><span class="p">(</span><span class="kc">False</span><span class="p">)</span>
            <span class="n">st</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_statinfo</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">st</span><span class="p">:</span>
                <span class="k">return</span> <span class="kc">False</span>
        <span class="k">return</span> <span class="n">S_ISBLK</span><span class="p">(</span><span class="n">st</span><span class="o">.</span><span class="n">st_mode</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">isSocket</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns whether the underlying path is a socket.</span>

<span class="sd">        @return: C{True} if it is a socket, C{False} otherwise</span>
<span class="sd">        @rtype: L{bool}</span>
<span class="sd">        @since: 11.1</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">st</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_statinfo</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">st</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">restat</span><span class="p">(</span><span class="kc">False</span><span class="p">)</span>
            <span class="n">st</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_statinfo</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">st</span><span class="p">:</span>
                <span class="k">return</span> <span class="kc">False</span>
        <span class="k">return</span> <span class="n">S_ISSOCK</span><span class="p">(</span><span class="n">st</span><span class="o">.</span><span class="n">st_mode</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">islink</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Check if this L{FilePath} points to a symbolic link.</span>

<span class="sd">        @return: C{True} if this L{FilePath} points to a symbolic link,</span>
<span class="sd">            C{False} otherwise.</span>
<span class="sd">        @rtype: L{bool}</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># We can&#39;t use cached stat results here, because that is the stat of</span>
        <span class="c1"># the destination - (see #1773) which in *every case* but this one is</span>
        <span class="c1"># the right thing to use.  We could call lstat here and use that, but</span>
        <span class="c1"># it seems unlikely we&#39;d actually save any work that way.  -glyph</span>
        <span class="k">return</span> <span class="n">islink</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">path</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">isabs</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Check if this L{FilePath} refers to an absolute path.</span>

<span class="sd">        This always returns C{True}.</span>

<span class="sd">        @return: C{True}, always.</span>
<span class="sd">        @rtype: L{bool}</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">isabs</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">path</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">listdir</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        List the base names of the direct children of this L{FilePath}.</span>

<span class="sd">        @return: A L{list} of L{bytes}/L{unicode} giving the names of the</span>
<span class="sd">            contents of the directory this L{FilePath} refers to. These names</span>
<span class="sd">            are relative to this L{FilePath}.</span>
<span class="sd">        @rtype: L{list}</span>

<span class="sd">        @raise: Anything the platform L{os.listdir} implementation might raise</span>
<span class="sd">            (typically L{OSError}).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">listdir</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">path</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">splitext</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Split the file path into a pair C{(root, ext)} such that</span>
<span class="sd">        C{root + ext == path}.</span>

<span class="sd">        @return: Tuple where the first item is the filename and second item is</span>
<span class="sd">            the file extension. See Python docs for L{os.path.splitext}.</span>
<span class="sd">        @rtype: L{tuple}</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">splitext</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">path</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="s1">&#39;FilePath(</span><span class="si">%r</span><span class="s1">)&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">path</span><span class="p">,)</span>


    <span class="k">def</span> <span class="nf">touch</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Updates the access and last modification times of the file at this</span>
<span class="sd">        file path to the current time. Also creates the file if it does not</span>
<span class="sd">        already exist.</span>

<span class="sd">        @raise Exception: if unable to create or modify the last modification</span>
<span class="sd">            time of the file.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">open</span><span class="p">(</span><span class="s1">&#39;a&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
        <span class="k">except</span> <span class="ne">IOError</span><span class="p">:</span>
            <span class="k">pass</span>
        <span class="n">utime</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">path</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">remove</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Removes the file or directory that is represented by self.  If</span>
<span class="sd">        C{self.path} is a directory, recursively remove all its children</span>
<span class="sd">        before removing the directory. If it&#39;s a file or link, just delete it.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">isdir</span><span class="p">()</span> <span class="ow">and</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">islink</span><span class="p">():</span>
            <span class="k">for</span> <span class="n">child</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">children</span><span class="p">():</span>
                <span class="n">child</span><span class="o">.</span><span class="n">remove</span><span class="p">()</span>
            <span class="n">os</span><span class="o">.</span><span class="n">rmdir</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">path</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">os</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">path</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">changed</span><span class="p">()</span>


    <span class="k">def</span> <span class="nf">makedirs</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ignoreExistingDirectory</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Create all directories not yet existing in C{path} segments, using</span>
<span class="sd">        L{os.makedirs}.</span>

<span class="sd">        @param ignoreExistingDirectory: Don&#39;t raise L{OSError} if directory</span>
<span class="sd">            already exists.</span>
<span class="sd">        @type ignoreExistingDirectory: L{bool}</span>

<span class="sd">        @return: L{None}</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">os</span><span class="o">.</span><span class="n">makedirs</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">path</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">OSError</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span>
                <span class="n">e</span><span class="o">.</span><span class="n">errno</span> <span class="o">==</span> <span class="n">errno</span><span class="o">.</span><span class="n">EEXIST</span> <span class="ow">and</span>
                <span class="n">ignoreExistingDirectory</span> <span class="ow">and</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">isdir</span><span class="p">()):</span>
                <span class="k">raise</span>


    <span class="k">def</span> <span class="nf">globChildren</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pattern</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Assuming I am representing a directory, return a list of FilePaths</span>
<span class="sd">        representing my children that match the given pattern.</span>

<span class="sd">        @param pattern: A glob pattern to use to match child paths.</span>
<span class="sd">        @type pattern: L{unicode} or L{bytes}</span>

<span class="sd">        @return: A L{list} of matching children.</span>
<span class="sd">        @rtype: L{list} of L{FilePath}, with the mode of C{pattern}&#39;s type</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">sep</span> <span class="o">=</span> <span class="n">_coerceToFilesystemEncoding</span><span class="p">(</span><span class="n">pattern</span><span class="p">,</span> <span class="n">os</span><span class="o">.</span><span class="n">sep</span><span class="p">)</span>
        <span class="n">ourPath</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_getPathAsSameTypeAs</span><span class="p">(</span><span class="n">pattern</span><span class="p">)</span>

        <span class="kn">import</span> <span class="nn">glob</span>
        <span class="n">path</span> <span class="o">=</span> <span class="n">ourPath</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="n">sep</span> <span class="ow">and</span> <span class="n">ourPath</span> <span class="o">+</span> <span class="n">pattern</span> \
               <span class="ow">or</span> <span class="n">sep</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="n">ourPath</span><span class="p">,</span> <span class="n">pattern</span><span class="p">])</span>
        <span class="k">return</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">clonePath</span><span class="p">(</span><span class="n">p</span><span class="p">)</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">glob</span><span class="o">.</span><span class="n">glob</span><span class="p">(</span><span class="n">path</span><span class="p">)]</span>


    <span class="k">def</span> <span class="nf">basename</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Retrieve the final component of the file path&#39;s path (everything</span>
<span class="sd">        after the final path separator).</span>

<span class="sd">        @return: The final component of the L{FilePath}&#39;s path (Everything</span>
<span class="sd">            after the final path separator).</span>
<span class="sd">        @rtype: the same type as this L{FilePath}&#39;s C{path} attribute</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">basename</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">path</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">dirname</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Retrieve all of the components of the L{FilePath}&#39;s path except the</span>
<span class="sd">        last one (everything up to the final path separator).</span>

<span class="sd">        @return: All of the components of the L{FilePath}&#39;s path except the</span>
<span class="sd">            last one (everything up to the final path separator).</span>
<span class="sd">        @rtype: the same type as this L{FilePath}&#39;s C{path} attribute</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">dirname</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">path</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">parent</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        A file path for the directory containing the file at this file path.</span>

<span class="sd">        @return: A L{FilePath} representing the path which directly contains</span>
<span class="sd">            this L{FilePath}.</span>
<span class="sd">        @rtype: L{FilePath}</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">clonePath</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dirname</span><span class="p">())</span>


    <span class="k">def</span> <span class="nf">setContent</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">content</span><span class="p">,</span> <span class="n">ext</span><span class="o">=</span><span class="sa">b</span><span class="s1">&#39;.new&#39;</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Replace the file at this path with a new file that contains the given</span>
<span class="sd">        bytes, trying to avoid data-loss in the meanwhile.</span>

<span class="sd">        On UNIX-like platforms, this method does its best to ensure that by the</span>
<span class="sd">        time this method returns, either the old contents I{or} the new</span>
<span class="sd">        contents of the file will be present at this path for subsequent</span>
<span class="sd">        readers regardless of premature device removal, program crash, or power</span>
<span class="sd">        loss, making the following assumptions:</span>

<span class="sd">            - your filesystem is journaled (i.e. your filesystem will not</span>
<span class="sd">              I{itself} lose data due to power loss)</span>

<span class="sd">            - your filesystem&#39;s C{rename()} is atomic</span>

<span class="sd">            - your filesystem will not discard new data while preserving new</span>
<span class="sd">              metadata (see U{http://mjg59.livejournal.com/108257.html} for</span>
<span class="sd">              more detail)</span>

<span class="sd">        On most versions of Windows there is no atomic C{rename()} (see</span>
<span class="sd">        U{http://bit.ly/win32-overwrite} for more information), so this method</span>
<span class="sd">        is slightly less helpful.  There is a small window where the file at</span>
<span class="sd">        this path may be deleted before the new file is moved to replace it:</span>
<span class="sd">        however, the new file will be fully written and flushed beforehand so</span>
<span class="sd">        in the unlikely event that there is a crash at that point, it should be</span>
<span class="sd">        possible for the user to manually recover the new version of their</span>
<span class="sd">        data.  In the future, Twisted will support atomic file moves on those</span>
<span class="sd">        versions of Windows which I{do} support them: see U{Twisted ticket</span>
<span class="sd">        3004&lt;http://twistedmatrix.com/trac/ticket/3004&gt;}.</span>

<span class="sd">        This method should be safe for use by multiple concurrent processes,</span>
<span class="sd">        but note that it is not easy to predict which process&#39;s contents will</span>
<span class="sd">        ultimately end up on disk if they invoke this method at close to the</span>
<span class="sd">        same time.</span>

<span class="sd">        @param content: The desired contents of the file at this path.</span>
<span class="sd">        @type content: L{bytes}</span>

<span class="sd">        @param ext: An extension to append to the temporary filename used to</span>
<span class="sd">            store the bytes while they are being written.  This can be used to</span>
<span class="sd">            make sure that temporary files can be identified by their suffix,</span>
<span class="sd">            for cleanup in case of crashes.</span>
<span class="sd">        @type ext: L{bytes}</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">sib</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">temporarySibling</span><span class="p">(</span><span class="n">ext</span><span class="p">)</span>
        <span class="k">with</span> <span class="n">sib</span><span class="o">.</span><span class="n">open</span><span class="p">(</span><span class="s1">&#39;w&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
            <span class="n">f</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">content</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">platform</span><span class="o">.</span><span class="n">isWindows</span><span class="p">()</span> <span class="ow">and</span> <span class="n">exists</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">path</span><span class="p">):</span>
            <span class="n">os</span><span class="o">.</span><span class="n">unlink</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">path</span><span class="p">)</span>
        <span class="n">os</span><span class="o">.</span><span class="n">rename</span><span class="p">(</span><span class="n">sib</span><span class="o">.</span><span class="n">path</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">asBytesMode</span><span class="p">()</span><span class="o">.</span><span class="n">path</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">__cmp__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">FilePath</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">NotImplemented</span>
        <span class="k">return</span> <span class="nb">cmp</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">path</span><span class="p">,</span> <span class="n">other</span><span class="o">.</span><span class="n">path</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">createDirectory</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Create the directory the L{FilePath} refers to.</span>

<span class="sd">        @see: L{makedirs}</span>

<span class="sd">        @raise OSError: If the directory cannot be created.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">os</span><span class="o">.</span><span class="n">mkdir</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">path</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">requireCreate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">val</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Sets the C{alwaysCreate} variable.</span>

<span class="sd">        @param val: C{True} or C{False}, indicating whether opening this path</span>
<span class="sd">            will be required to create the file or not.</span>
<span class="sd">        @type val: L{bool}</span>

<span class="sd">        @return: L{None}</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">alwaysCreate</span> <span class="o">=</span> <span class="n">val</span>


    <span class="k">def</span> <span class="nf">create</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Exclusively create a file, only if this file previously did not exist.</span>

<span class="sd">        @return: A file-like object opened from this path.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">fdint</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">open</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">path</span><span class="p">,</span> <span class="n">_CREATE_FLAGS</span><span class="p">)</span>

        <span class="c1"># XXX TODO: &#39;name&#39; attribute of returned files is not mutable or</span>
        <span class="c1"># settable via fdopen, so this file is slightly less functional than the</span>
        <span class="c1"># one returned from &#39;open&#39; by default.  send a patch to Python...</span>

        <span class="k">return</span> <span class="n">os</span><span class="o">.</span><span class="n">fdopen</span><span class="p">(</span><span class="n">fdint</span><span class="p">,</span> <span class="s1">&#39;w+b&#39;</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">temporarySibling</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">extension</span><span class="o">=</span><span class="sa">b</span><span class="s2">&quot;&quot;</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Construct a path referring to a sibling of this path.</span>

<span class="sd">        The resulting path will be unpredictable, so that other subprocesses</span>
<span class="sd">        should neither accidentally attempt to refer to the same path before it</span>
<span class="sd">        is created, nor they should other processes be able to guess its name</span>
<span class="sd">        in advance.</span>

<span class="sd">        @param extension: A suffix to append to the created filename.  (Note</span>
<span class="sd">            that if you want an extension with a &#39;.&#39; you must include the &#39;.&#39;</span>
<span class="sd">            yourself.)</span>
<span class="sd">        @type extension: L{bytes} or L{unicode}</span>

<span class="sd">        @return: a path object with the given extension suffix, C{alwaysCreate}</span>
<span class="sd">            set to True.</span>
<span class="sd">        @rtype: L{FilePath} with a mode equal to the type of C{extension}</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">ourPath</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_getPathAsSameTypeAs</span><span class="p">(</span><span class="n">extension</span><span class="p">)</span>
        <span class="n">sib</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sibling</span><span class="p">(</span><span class="n">_secureEnoughString</span><span class="p">(</span><span class="n">ourPath</span><span class="p">)</span> <span class="o">+</span>
                           <span class="bp">self</span><span class="o">.</span><span class="n">clonePath</span><span class="p">(</span><span class="n">ourPath</span><span class="p">)</span><span class="o">.</span><span class="n">basename</span><span class="p">()</span> <span class="o">+</span> <span class="n">extension</span><span class="p">)</span>
        <span class="n">sib</span><span class="o">.</span><span class="n">requireCreate</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">sib</span>


    <span class="n">_chunkSize</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">**</span> <span class="mi">2</span>

    <span class="k">def</span> <span class="nf">copyTo</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">destination</span><span class="p">,</span> <span class="n">followLinks</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Copies self to destination.</span>

<span class="sd">        If self doesn&#39;t exist, an OSError is raised.</span>

<span class="sd">        If self is a directory, this method copies its children (but not</span>
<span class="sd">        itself) recursively to destination - if destination does not exist as a</span>
<span class="sd">        directory, this method creates it.  If destination is a file, an</span>
<span class="sd">        IOError will be raised.</span>

<span class="sd">        If self is a file, this method copies it to destination.  If</span>
<span class="sd">        destination is a file, this method overwrites it.  If destination is a</span>
<span class="sd">        directory, an IOError will be raised.</span>

<span class="sd">        If self is a link (and followLinks is False), self will be copied</span>
<span class="sd">        over as a new symlink with the same target as returned by os.readlink.</span>
<span class="sd">        That means that if it is absolute, both the old and new symlink will</span>
<span class="sd">        link to the same thing.  If it&#39;s relative, then perhaps not (and</span>
<span class="sd">        it&#39;s also possible that this relative link will be broken).</span>

<span class="sd">        File/directory permissions and ownership will NOT be copied over.</span>

<span class="sd">        If followLinks is True, symlinks are followed so that they&#39;re treated</span>
<span class="sd">        as their targets.  In other words, if self is a link, the link&#39;s target</span>
<span class="sd">        will be copied.  If destination is a link, self will be copied to the</span>
<span class="sd">        destination&#39;s target (the actual destination will be destination&#39;s</span>
<span class="sd">        target).  Symlinks under self (if self is a directory) will be</span>
<span class="sd">        followed and its target&#39;s children be copied recursively.</span>

<span class="sd">        If followLinks is False, symlinks will be copied over as symlinks.</span>

<span class="sd">        @param destination: the destination (a FilePath) to which self</span>
<span class="sd">            should be copied</span>
<span class="sd">        @param followLinks: whether symlinks in self should be treated as links</span>
<span class="sd">            or as their targets</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">islink</span><span class="p">()</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">followLinks</span><span class="p">:</span>
            <span class="n">os</span><span class="o">.</span><span class="n">symlink</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">readlink</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">path</span><span class="p">),</span> <span class="n">destination</span><span class="o">.</span><span class="n">path</span><span class="p">)</span>
            <span class="k">return</span>
        <span class="c1"># XXX TODO: *thorough* audit and documentation of the exact desired</span>
        <span class="c1"># semantics of this code.  Right now the behavior of existent</span>
        <span class="c1"># destination symlinks is convenient, and quite possibly correct, but</span>
        <span class="c1"># its security properties need to be explained.</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">isdir</span><span class="p">():</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">destination</span><span class="o">.</span><span class="n">exists</span><span class="p">():</span>
                <span class="n">destination</span><span class="o">.</span><span class="n">createDirectory</span><span class="p">()</span>
            <span class="k">for</span> <span class="n">child</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">children</span><span class="p">():</span>
                <span class="n">destChild</span> <span class="o">=</span> <span class="n">destination</span><span class="o">.</span><span class="n">child</span><span class="p">(</span><span class="n">child</span><span class="o">.</span><span class="n">basename</span><span class="p">())</span>
                <span class="n">child</span><span class="o">.</span><span class="n">copyTo</span><span class="p">(</span><span class="n">destChild</span><span class="p">,</span> <span class="n">followLinks</span><span class="p">)</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">isfile</span><span class="p">():</span>
            <span class="k">with</span> <span class="n">destination</span><span class="o">.</span><span class="n">open</span><span class="p">(</span><span class="s1">&#39;w&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">writefile</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">open</span><span class="p">()</span> <span class="k">as</span> <span class="n">readfile</span><span class="p">:</span>
                <span class="k">while</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="c1"># XXX TODO: optionally use os.open, os.read and</span>
                    <span class="c1"># O_DIRECT and use os.fstatvfs to determine chunk sizes</span>
                    <span class="c1"># and make *****sure**** copy is page-atomic; the</span>
                    <span class="c1"># following is good enough for 99.9% of everybody and</span>
                    <span class="c1"># won&#39;t take a week to audit though.</span>
                    <span class="n">chunk</span> <span class="o">=</span> <span class="n">readfile</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_chunkSize</span><span class="p">)</span>
                    <span class="n">writefile</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">chunk</span><span class="p">)</span>
                    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">chunk</span><span class="p">)</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">_chunkSize</span><span class="p">:</span>
                        <span class="k">break</span>
        <span class="k">elif</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">exists</span><span class="p">():</span>
            <span class="k">raise</span> <span class="ne">OSError</span><span class="p">(</span><span class="n">errno</span><span class="o">.</span><span class="n">ENOENT</span><span class="p">,</span> <span class="s2">&quot;No such file or directory&quot;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># If you see the following message because you want to copy</span>
            <span class="c1"># symlinks, fifos, block devices, character devices, or unix</span>
            <span class="c1"># sockets, please feel free to add support to do sensible things in</span>
            <span class="c1"># reaction to those types!</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span>
                <span class="s2">&quot;Only copying of files and directories supported&quot;</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">moveTo</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">destination</span><span class="p">,</span> <span class="n">followLinks</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Move self to destination - basically renaming self to whatever</span>
<span class="sd">        destination is named.</span>

<span class="sd">        If destination is an already-existing directory,</span>
<span class="sd">        moves all children to destination if destination is empty.  If</span>
<span class="sd">        destination is a non-empty directory, or destination is a file, an</span>
<span class="sd">        OSError will be raised.</span>

<span class="sd">        If moving between filesystems, self needs to be copied, and everything</span>
<span class="sd">        that applies to copyTo applies to moveTo.</span>

<span class="sd">        @param destination: the destination (a FilePath) to which self</span>
<span class="sd">            should be copied</span>
<span class="sd">        @param followLinks: whether symlinks in self should be treated as links</span>
<span class="sd">            or as their targets (only applicable when moving between</span>
<span class="sd">            filesystems)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">os</span><span class="o">.</span><span class="n">rename</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_getPathAsSameTypeAs</span><span class="p">(</span><span class="n">destination</span><span class="o">.</span><span class="n">path</span><span class="p">),</span>
                      <span class="n">destination</span><span class="o">.</span><span class="n">path</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">OSError</span> <span class="k">as</span> <span class="n">ose</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">ose</span><span class="o">.</span><span class="n">errno</span> <span class="o">==</span> <span class="n">errno</span><span class="o">.</span><span class="n">EXDEV</span><span class="p">:</span>
                <span class="c1"># man 2 rename, ubuntu linux 5.10 &quot;breezy&quot;:</span>

                <span class="c1">#   oldpath and newpath are not on the same mounted filesystem.</span>
                <span class="c1">#   (Linux permits a filesystem to be mounted at multiple</span>
                <span class="c1">#   points, but rename(2) does not work across different mount</span>
                <span class="c1">#   points, even if the same filesystem is mounted on both.)</span>

                <span class="c1"># that means it&#39;s time to copy trees of directories!</span>
                <span class="n">secsib</span> <span class="o">=</span> <span class="n">destination</span><span class="o">.</span><span class="n">temporarySibling</span><span class="p">()</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">copyTo</span><span class="p">(</span><span class="n">secsib</span><span class="p">,</span> <span class="n">followLinks</span><span class="p">)</span> <span class="c1"># slow</span>
                <span class="n">secsib</span><span class="o">.</span><span class="n">moveTo</span><span class="p">(</span><span class="n">destination</span><span class="p">,</span> <span class="n">followLinks</span><span class="p">)</span> <span class="c1"># visible</span>

                <span class="c1"># done creating new stuff.  let&#39;s clean me up.</span>
                <span class="n">mysecsib</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">temporarySibling</span><span class="p">()</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">moveTo</span><span class="p">(</span><span class="n">mysecsib</span><span class="p">,</span> <span class="n">followLinks</span><span class="p">)</span> <span class="c1"># visible</span>
                <span class="n">mysecsib</span><span class="o">.</span><span class="n">remove</span><span class="p">()</span> <span class="c1"># slow</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">changed</span><span class="p">()</span>
            <span class="n">destination</span><span class="o">.</span><span class="n">changed</span><span class="p">()</span>


    <span class="k">def</span> <span class="nf">statinfo</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="o">=</span><span class="n">_SpecialNoValue</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        FilePath.statinfo is deprecated.</span>

<span class="sd">        @param value: value to set statinfo to, if setting a value</span>
<span class="sd">        @return: C{_statinfo} if getting, L{None} if setting</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># This is a pretty awful hack to use the deprecated decorator to</span>
        <span class="c1"># deprecate a class attribute.  Ideally, there would just be a</span>
        <span class="c1"># statinfo property and a statinfo property setter, but the</span>
        <span class="c1"># &#39;deprecated&#39; decorator does not produce the correct FQDN on class</span>
        <span class="c1"># methods.  So the property stuff needs to be set outside the class</span>
        <span class="c1"># definition - but the getter and setter both need the same function</span>
        <span class="c1"># in order for the &#39;deprecated&#39; decorator to produce the right</span>
        <span class="c1"># deprecation string.</span>
        <span class="k">if</span> <span class="n">value</span> <span class="ow">is</span> <span class="n">_SpecialNoValue</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_statinfo</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_statinfo</span> <span class="o">=</span> <span class="n">value</span>


<span class="c1"># This is all a terrible hack to get statinfo deprecated</span>
<span class="n">_tmp</span> <span class="o">=</span> <span class="n">deprecated</span><span class="p">(</span>
    <span class="n">Version</span><span class="p">(</span><span class="s1">&#39;Twisted&#39;</span><span class="p">,</span> <span class="mi">15</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span>
    <span class="s2">&quot;other FilePath methods such as getsize(), &quot;</span>
    <span class="s2">&quot;isdir(), getModificationTime(), etc.&quot;</span><span class="p">)(</span><span class="n">FilePath</span><span class="o">.</span><span class="n">statinfo</span><span class="p">)</span>
<span class="n">FilePath</span><span class="o">.</span><span class="n">statinfo</span> <span class="o">=</span> <span class="nb">property</span><span class="p">(</span><span class="n">_tmp</span><span class="p">,</span> <span class="n">_tmp</span><span class="p">)</span>


<span class="n">FilePath</span><span class="o">.</span><span class="n">clonePath</span> <span class="o">=</span> <span class="n">FilePath</span>
</pre></div>

           </div>
           
          </div>
          <footer>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2018, Pol Canelles.

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  

    <script type="text/javascript">
        var DOCUMENTATION_OPTIONS = {
            URL_ROOT:'../../../',
            VERSION:'0.8.0',
            LANGUAGE:'None',
            COLLAPSE_INDEX:false,
            FILE_SUFFIX:'.html',
            HAS_SOURCE:  true,
            SOURCELINK_SUFFIX: '.txt'
        };
    </script>
      <script type="text/javascript" src="../../../_static/jquery.js"></script>
      <script type="text/javascript" src="../../../_static/underscore.js"></script>
      <script type="text/javascript" src="../../../_static/doctools.js"></script>
      <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

  

  <script type="text/javascript" src="../../../_static/js/theme.js"></script>

  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>