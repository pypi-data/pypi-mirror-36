import os
from string import Template
from os.path import join, expanduser, expandvars, exists
from argparse import RawDescriptionHelpFormatter
from configobj import ConfigObj, Section
from sge.util.arg_parser import ArgParser
from sge_server.util import install_server

parser = ArgParser(prog="remote_sge request_cert",
                   formatter_class=RawDescriptionHelpFormatter)

DESCRIPTION = """For requesting a signed certificate from the certificate authority at [remote_host].

* Creates an encryption key if one is not there, or if -f is specified.
* Generates a CSR and places it in $HOME where it can be submitted for signing.

The certificate is signed by an admin of the given [remote_host], and then
the user should install it with `remote_sge install_cert`.

The [endpoint] argument creates a config section which can be referred to in
subsequent calls to `remote_sge shuttle`, and can be ignored until you have
more than one remote that this client will connect to.

If [endpoint] is "default" or omitted then instead of creating a new config
section, the default configuration information will be overwritten.

After the CSR is created it should be scp'd to the [remote_host], and a
certificate generated with *remote_sge sign_certificate*.
"""

def parse_args():
    parser.add_argument('request_cert', help='Command being run')
    parser.add_argument('remote_host', help='Remote host that this config entry refers to. ' +
                        "MUST be an IP Address or DNS name mentioned on the server certificate.")
    parser.add_argument('endpoint', help='endpoint for server being added. Optional. '+
                        'Creates a new config setting and allows for multiple servers ' +
                        'managed by this client.',
                        default="default", nargs="?")
    parser.add_argument('-p', '--port', help="Port number to connect.  Default 443.",
                        default=443)
    parser.add_argument('-f', '--force', action="store_true",
                        help="Force overwrite keyfile at $CONFDIR/clientkey.pem")
    parser.add_argument('-r', '--root',
                        help="Moves config root from ~/.config/remote_sge.  See online docs.",
                        default="$HOME/.config/remote_sge")
    parser.add_argument('-u', '--use_https', help="For debugging purposes only.  Default: 'yes.",
                        default="yes")
    parser.description = DESCRIPTION
    return parser.parse_args()


CREATE_CLIENT_KEY="openssl genrsa -out ${key_path} 2048"
CREATE_CLIENT_CSR=("openssl req -new -key ${key_path} "+
                    "-out ${csr_path}")

def print_important(message, char="*", space=" ", xmargin=5, ymargin=1):
    lines = ["" for x in range(0, ymargin)] + message.split("\n") + ["" for x in range(0, ymargin)]
    maxlen = max(len(line) for line in lines)
    nasterisks = 2 * xmargin + 2 + maxlen
    print(char * nasterisks)
    for line in lines:
        print(char + space * xmargin + line + space * (maxlen-len(line)) + space * xmargin + char)
    print(char * nasterisks)

def make_config(args, certs_path, prefix):
    return dict(host=(args.remote_host),
                port=args.port,
                client_certificate=join(certs_path, "%sclientcert.pem" % prefix),
                client_key=join(certs_path, "clientkey.pem"),
                ca_certificate=join(certs_path, "%scacert.pem" % prefix),
                use_https=args.use_https)

CLI_CSR = ("openssl req -config ${conf_file} %s " +
           "-sha256 -nodes -out ${csr_path} -outform PEM ")

USE_KEY = "-new -key %s"
MAKE_KEY = "-keyout ${certs_path}/clientkey.pem -newkey rsa:2048"

def main():
    args = parse_args()
    config_root = expanduser(expandvars(args.root))
    certs_path = join(config_root, 'certs')
    os.system("mkdir -p " + certs_path)
    if args.endpoint == "default":
        key_name = "clientkey"
        cert_name = "clientcert"
    else:
        key_name = args.endpoint + "_clientkey"
        cert_name = args.endpoint + "_clientcert"
    key_path = join(certs_path, "clientkey.pem")
    csr_path = expandvars("~/${USER}@${HOSTNAME}.%s.csr" % cert_name)
    if exists(key_path) and not args.force:
        print_important("Not creating a new key because %s already exists.\n" % key_path +
                        "Use -f to force overwrite.")
        cmd = CLI_CSR % (USE_KEY % key_path)
    else:
        if exists(key_path):
            print_important("Overwriting your private key at " + key_path + "!\n" +
                            "Any certificates generated by this key will have to be " +
                            "renewed with your new key!")
            os.system("chmod 600 %s; rm %s" % (key_path, key_path))
        cmd = CLI_CSR % MAKE_KEY

    os.system(Template(cmd).substitute(conf_file=join(args.root, 'openssl-client.ini'),
                                       certs_path=certs_path,
                                       csr_path=csr_path))
    os.system("chmod 400 " + key_path)
    config = ConfigObj(infile=join(config_root, 'config.ini'))

    if args.endpoint == "default":
        config["client"] = make_config(args, certs_path, "")
    else:
        config["client"][args.endpoint] = make_config(args, certs_path, args.endpoint + "_")

    config.write()

    final_message = FINISHED_MESSAGE + "[ client ]\n"
    for x, y in config["client"].items():
        if type(y) is Section:
            final_message += "\n[[ " + x + " ]]\n"
            for xx, yy in y.items():
                final_message += "%s = %s\n" % (xx, yy)
        else:
            final_message += "%s = %s\n" % (x, y)

    print_important(Template(final_message).substitute(csr_path=csr_path,
                                                       config_path=join(config_root, 'config.ini'),
                                                       crt_path=join(certs_path, key_name + '.crt')))


FINISHED_MESSAGE = """

Your CSR was created at ${csr_path}.  Please use
scp to send it to the remote server and use *remote_sge sign_cert* 
to create a certificate.

Please review the settings created, and edit ${config_path}
if anything doesn't look right.

"""

if __name__ == '__main__':
    main()
