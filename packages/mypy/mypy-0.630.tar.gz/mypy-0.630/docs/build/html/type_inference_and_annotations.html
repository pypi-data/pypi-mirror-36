
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="X-UA-Compatible" content="IE=Edge" />
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <title>Type inference and type annotations &#8212; Mypy 0.630+dev-734a166d380bfb0de05ce0e3c61dc7e675898e9c-dirty documentation</title>
    <link rel="stylesheet" href="_static/classic.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    <script type="text/javascript" id="documentation_options" data-url_root="./" src="_static/documentation_options.js"></script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="Kinds of types" href="kinds_of_types.html" />
    <link rel="prev" title="Built-in types" href="builtin_types.html" /> 
  </head><body>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="kinds_of_types.html" title="Kinds of types"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="builtin_types.html" title="Built-in types"
             accesskey="P">previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="index.html">Mypy 0.630+dev-734a166d380bfb0de05ce0e3c61dc7e675898e9c-dirty documentation</a> &#187;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="type-inference-and-type-annotations">
<h1>Type inference and type annotations<a class="headerlink" href="#type-inference-and-type-annotations" title="Permalink to this headline">¶</a></h1>
<div class="section" id="type-inference">
<h2>Type inference<a class="headerlink" href="#type-inference" title="Permalink to this headline">¶</a></h2>
<p>Mypy considers the initial assignment as the definition of a variable.
If you do not explicitly
specify the type of the variable, mypy infers the type based on the
static type of the value expression:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">i</span> <span class="o">=</span> <span class="mi">1</span>           <span class="c1"># Infer type &quot;int&quot; for i</span>
<span class="n">l</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span>      <span class="c1"># Infer type &quot;List[int]&quot; for l</span>
</pre></div>
</div>
<p>Type inference is not used in dynamically typed functions (those
without a function type annotation) — every local variable type defaults
to <code class="docutils literal notranslate"><span class="pre">Any</span></code> in such functions. <code class="docutils literal notranslate"><span class="pre">Any</span></code> is discussed later in more detail.</p>
</div>
<div class="section" id="explicit-types-for-variables">
<span id="explicit-var-types"></span><h2>Explicit types for variables<a class="headerlink" href="#explicit-types-for-variables" title="Permalink to this headline">¶</a></h2>
<p>You can override the inferred type of a variable by using a
variable type annotation:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">Union</span>

<span class="n">x</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
</pre></div>
</div>
<p>Without the type annotation, the type of <code class="docutils literal notranslate"><span class="pre">x</span></code> would be just <code class="docutils literal notranslate"><span class="pre">int</span></code>. We
use an annotation to give it a more general type <code class="docutils literal notranslate"><span class="pre">Union[int,</span> <span class="pre">str]</span></code> (this
type means that the value can be either an <code class="docutils literal notranslate"><span class="pre">int</span></code> or a <code class="docutils literal notranslate"><span class="pre">str</span></code>).
Mypy checks that the type of the initializer is compatible with the
declared type. The following example is not valid, since the initializer is
a floating point number, and this is incompatible with the declared
type:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">x</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="mf">1.1</span>  <span class="c1"># Error!</span>
</pre></div>
</div>
<p>The variable annotation syntax is available starting from Python 3.6.
In earlier Python versions, you can use a special comment after an
assignment statement to declare the type of a variable:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">x</span> <span class="o">=</span> <span class="mi">1</span>  <span class="c1"># type: Union[int, str]</span>
</pre></div>
</div>
<p>We’ll use both syntax variants in examples. The syntax variants are
mostly interchangeable, but the variable annotation syntax allows
defining the type of a variable without initialization, which is not
possible with the comment syntax:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">x</span><span class="p">:</span> <span class="nb">str</span>  <span class="c1"># Declare type of &#39;x&#39; without initialization</span>
</pre></div>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">The best way to think about this is that the type annotation sets the
type of the variable, not the type of the expression. To force the
type of an expression you can use <code class="docutils literal notranslate"><span class="pre">cast(&lt;type&gt;,</span> <span class="pre">&lt;expression&gt;)</span></code>.</p>
</div>
</div>
<div class="section" id="explicit-types-for-collections">
<h2>Explicit types for collections<a class="headerlink" href="#explicit-types-for-collections" title="Permalink to this headline">¶</a></h2>
<p>The type checker cannot always infer the type of a list or a
dictionary. This often arises when creating an empty list or
dictionary and assigning it to a new variable that doesn’t have an explicit
variable type. Here is an example where mypy can’t infer the type
without some help:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">l</span> <span class="o">=</span> <span class="p">[]</span>  <span class="c1"># Error: Need type annotation for &#39;l&#39;</span>
</pre></div>
</div>
<p>In these cases you can give the type explicitly using a type annotation:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">l</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>       <span class="c1"># Create empty list with type List[int]</span>
<span class="n">d</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="p">{}</span>  <span class="c1"># Create empty dictionary (str -&gt; int)</span>
</pre></div>
</div>
<p>Similarly, you can also give an explicit type when creating an empty set:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">s</span><span class="p">:</span> <span class="n">Set</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="section" id="compatibility-of-container-types">
<h2>Compatibility of container types<a class="headerlink" href="#compatibility-of-container-types" title="Permalink to this headline">¶</a></h2>
<p>The following program generates a mypy error, since <code class="docutils literal notranslate"><span class="pre">List[int]</span></code>
is not compatible with <code class="docutils literal notranslate"><span class="pre">List[object]</span></code>:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">f</span><span class="p">(</span><span class="n">l</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">object</span><span class="p">],</span> <span class="n">k</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="bp">None</span><span class="p">:</span>
    <span class="n">l</span> <span class="o">=</span> <span class="n">k</span>  <span class="c1"># Type check error: incompatible types in assignment</span>
</pre></div>
</div>
<p>The reason why the above assignment is disallowed is that allowing the
assignment could result in non-int values stored in a list of <code class="docutils literal notranslate"><span class="pre">int</span></code>:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">f</span><span class="p">(</span><span class="n">l</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">object</span><span class="p">],</span> <span class="n">k</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="bp">None</span><span class="p">:</span>
    <span class="n">l</span> <span class="o">=</span> <span class="n">k</span>
    <span class="n">l</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s1">&#39;x&#39;</span><span class="p">)</span>
    <span class="k">print</span><span class="p">(</span><span class="n">k</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>  <span class="c1"># Ouch; a string in List[int]</span>
</pre></div>
</div>
<p>Other container types like <code class="docutils literal notranslate"><span class="pre">Dict</span></code> and <code class="docutils literal notranslate"><span class="pre">Set</span></code> behave similarly. We
will discuss how you can work around this in <a class="reference internal" href="common_issues.html#variance"><span class="std std-ref">Invariance vs covariance</span></a>.</p>
<p>You can still run the above program; it prints <code class="docutils literal notranslate"><span class="pre">x</span></code>. This illustrates
the fact that static types are used during type checking, but they do
not affect the runtime behavior of programs. You can run programs with
type check failures, which is often very handy when performing a large
refactoring. Thus you can always ‘work around’ the type system, and it
doesn’t really limit what you can do in your program.</p>
</div>
<div class="section" id="context-in-type-inference">
<h2>Context in type inference<a class="headerlink" href="#context-in-type-inference" title="Permalink to this headline">¶</a></h2>
<p>Type inference is <em>bidirectional</em> and takes context into account. For
example, the following is valid:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">f</span><span class="p">(</span><span class="n">l</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">object</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="bp">None</span><span class="p">:</span>
    <span class="n">l</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span>  <span class="c1"># Infer type List[object] for [1, 2], not List[int]</span>
</pre></div>
</div>
<p>In an assignment, the type context is determined by the assignment
target. In this case this is <code class="docutils literal notranslate"><span class="pre">l</span></code>, which has the type
<code class="docutils literal notranslate"><span class="pre">List[object]</span></code>. The value expression <code class="docutils literal notranslate"><span class="pre">[1,</span> <span class="pre">2]</span></code> is type checked in
this context and given the type <code class="docutils literal notranslate"><span class="pre">List[object]</span></code>. In the previous
example we introduced a new variable <code class="docutils literal notranslate"><span class="pre">l</span></code>, and here the type context
was empty.</p>
<p>Declared argument types are also used for type context. In this program
mypy knows that the empty list <code class="docutils literal notranslate"><span class="pre">[]</span></code> should have type <code class="docutils literal notranslate"><span class="pre">List[int]</span></code> based
on the declared type of <code class="docutils literal notranslate"><span class="pre">arg</span></code> in <code class="docutils literal notranslate"><span class="pre">foo</span></code>:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">foo</span><span class="p">(</span><span class="n">arg</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="bp">None</span><span class="p">:</span>
    <span class="k">print</span><span class="p">(</span><span class="s1">&#39;Items:&#39;</span><span class="p">,</span> <span class="s1">&#39;&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">arg</span><span class="p">))</span>

<span class="n">foo</span><span class="p">([])</span>  <span class="c1"># OK</span>
</pre></div>
</div>
<p>However, context only works within a single statement. Here mypy requires
an annotation for the empty list, since the context would only be available
in the following statement:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">foo</span><span class="p">(</span><span class="n">arg</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="bp">None</span><span class="p">:</span>
    <span class="k">print</span><span class="p">(</span><span class="n">Items</span><span class="p">:</span> <span class="s1">&#39;, &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">arg</span><span class="p">))</span>

<span class="n">a</span> <span class="o">=</span> <span class="p">[]</span>  <span class="c1"># Error: Need type annotation for &#39;a&#39;</span>
<span class="n">foo</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
</pre></div>
</div>
<p>Working around the issue is easy by adding a type annotation:</p>
<div class="highlight-Python notranslate"><div class="highlight"><pre><span></span><span class="o">...</span>
<span class="n">a</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>  <span class="c1"># OK</span>
<span class="n">foo</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="section" id="declaring-multiple-variable-types-at-a-time">
<h2>Declaring multiple variable types at a time<a class="headerlink" href="#declaring-multiple-variable-types-at-a-time" title="Permalink to this headline">¶</a></h2>
<p>You can declare more than a single variable at a time, but only with
a type comment. In order to nicely work with multiple assignment, you
must give each variable a type separately:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">i</span><span class="p">,</span> <span class="n">found</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="bp">False</span> <span class="c1"># type: int, bool</span>
</pre></div>
</div>
<p>You can optionally use parentheses around the types, assignment targets
and assigned expression:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">i</span><span class="p">,</span> <span class="n">found</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="bp">False</span> <span class="c1"># type: (int, bool)      # OK</span>
<span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">found</span><span class="p">)</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="bp">False</span> <span class="c1"># type: int, bool      # OK</span>
<span class="n">i</span><span class="p">,</span> <span class="n">found</span> <span class="o">=</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="bp">False</span><span class="p">)</span> <span class="c1"># type: int, bool      # OK</span>
<span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">found</span><span class="p">)</span> <span class="o">=</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="bp">False</span><span class="p">)</span> <span class="c1"># type: (int, bool)  # OK</span>
</pre></div>
</div>
</div>
<div class="section" id="starred-expressions">
<h2>Starred expressions<a class="headerlink" href="#starred-expressions" title="Permalink to this headline">¶</a></h2>
<p>In most cases, mypy can infer the type of starred expressions from the
right-hand side of an assignment, but not always:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">a</span><span class="p">,</span> <span class="o">*</span><span class="n">bs</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span>   <span class="c1"># OK</span>
<span class="n">p</span><span class="p">,</span> <span class="n">q</span><span class="p">,</span> <span class="o">*</span><span class="n">rs</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span>   <span class="c1"># Error: Type of rs cannot be inferred</span>
</pre></div>
</div>
<p>On first line, the type of <code class="docutils literal notranslate"><span class="pre">bs</span></code> is inferred to be
<code class="docutils literal notranslate"><span class="pre">List[int]</span></code>. However, on the second line, mypy cannot infer the type
of <code class="docutils literal notranslate"><span class="pre">rs</span></code>, because there is no right-hand side value for <code class="docutils literal notranslate"><span class="pre">rs</span></code> to
infer the type from. In cases like these, the starred expression needs
to be annotated with a starred type:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">p</span><span class="p">,</span> <span class="n">q</span><span class="p">,</span> <span class="o">*</span><span class="n">rs</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span>  <span class="c1"># type: int, int, *List[int]</span>
</pre></div>
</div>
<p>Here, the type of <code class="docutils literal notranslate"><span class="pre">rs</span></code> is set to <code class="docutils literal notranslate"><span class="pre">List[int]</span></code>.</p>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <h3><a href="index.html">Table Of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">Type inference and type annotations</a><ul>
<li><a class="reference internal" href="#type-inference">Type inference</a></li>
<li><a class="reference internal" href="#explicit-types-for-variables">Explicit types for variables</a></li>
<li><a class="reference internal" href="#explicit-types-for-collections">Explicit types for collections</a></li>
<li><a class="reference internal" href="#compatibility-of-container-types">Compatibility of container types</a></li>
<li><a class="reference internal" href="#context-in-type-inference">Context in type inference</a></li>
<li><a class="reference internal" href="#declaring-multiple-variable-types-at-a-time">Declaring multiple variable types at a time</a></li>
<li><a class="reference internal" href="#starred-expressions">Starred expressions</a></li>
</ul>
</li>
</ul>

  <h4>Previous topic</h4>
  <p class="topless"><a href="builtin_types.html"
                        title="previous chapter">Built-in types</a></p>
  <h4>Next topic</h4>
  <p class="topless"><a href="kinds_of_types.html"
                        title="next chapter">Kinds of types</a></p>
  <div role="note" aria-label="source link">
    <h3>This Page</h3>
    <ul class="this-page-menu">
      <li><a href="_sources/type_inference_and_annotations.rst.txt"
            rel="nofollow">Show Source</a></li>
    </ul>
   </div>
<div id="searchbox" style="display: none" role="search">
  <h3>Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    </div>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="kinds_of_types.html" title="Kinds of types"
             >next</a> |</li>
        <li class="right" >
          <a href="builtin_types.html" title="Built-in types"
             >previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="index.html">Mypy 0.630+dev-734a166d380bfb0de05ce0e3c61dc7e675898e9c-dirty documentation</a> &#187;</li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
        &#169; Copyright 2016, Jukka Lehtosalo.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.7.5.
    </div>
  </body>
</html>