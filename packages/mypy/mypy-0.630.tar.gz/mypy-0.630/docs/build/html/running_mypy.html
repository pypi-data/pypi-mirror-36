
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="X-UA-Compatible" content="IE=Edge" />
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <title>Running mypy and managing imports &#8212; Mypy 0.630+dev-734a166d380bfb0de05ce0e3c61dc7e675898e9c-dirty documentation</title>
    <link rel="stylesheet" href="_static/classic.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    <script type="text/javascript" id="documentation_options" data-url_root="./" src="_static/documentation_options.js"></script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="The mypy command line" href="command_line.html" />
    <link rel="prev" title="Metaclasses" href="metaclasses.html" /> 
  </head><body>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="command_line.html" title="The mypy command line"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="metaclasses.html" title="Metaclasses"
             accesskey="P">previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="index.html">Mypy 0.630+dev-734a166d380bfb0de05ce0e3c61dc7e675898e9c-dirty documentation</a> &#187;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="running-mypy-and-managing-imports">
<span id="running-mypy"></span><h1>Running mypy and managing imports<a class="headerlink" href="#running-mypy-and-managing-imports" title="Permalink to this headline">¶</a></h1>
<p>The <a class="reference internal" href="getting_started.html#getting-started"><span class="std std-ref">Getting started</span></a> page should have already introduced you
to the basics of how to run mypy – pass in the files and directories
you want to type check via the command line:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>$ mypy foo.py bar.py some_directory
</pre></div>
</div>
<p>This page discusses in more detail how exactly to specify what files
you want mypy to type check, how mypy discovers imported modules,
and recommendations on how to handle any issues you may encounter
along the way.</p>
<p>If you are interested in learning about how to configure the
actual way mypy type checks your code, see our
<a class="reference internal" href="command_line.html#command-line"><span class="std std-ref">The mypy command line</span></a> guide.</p>
<div class="section" id="specifying-code-to-be-checked">
<span id="id1"></span><h2>Specifying code to be checked<a class="headerlink" href="#specifying-code-to-be-checked" title="Permalink to this headline">¶</a></h2>
<p>Mypy lets you specify what files it should type check in several
different ways.</p>
<ol class="arabic">
<li><p class="first">First, you can pass in paths to Python files and directories you
want to type check. For example:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>$ mypy file_1.py foo/file_2.py file_3.pyi some/directory
</pre></div>
</div>
<p>The above command tells mypy it should type check all of the provided
files together. In addition, mypy will recursively type check the
entire contents of any provided directories.</p>
<p>For more details about how exactly this is done, see
<a class="reference internal" href="#mapping-paths-to-modules"><span class="std std-ref">Mapping file paths to modules</span></a>.</p>
</li>
<li><p class="first">Second, you can use the <code class="docutils literal notranslate"><span class="pre">-m</span></code> flag (long form: <code class="docutils literal notranslate"><span class="pre">--module</span></code>) to
specify a module name to be type checked. The name of a module
is identical to the name you would use to import that module
within a Python program. For example, running:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>$ mypy -m html.parser
</pre></div>
</div>
<p>…will type check the module <code class="docutils literal notranslate"><span class="pre">html.parser</span></code> (this happens to be
a library stub).</p>
<p>Mypy will use an algorithm very similar to the one Python uses to
find where modules and imports are located on the file system.
For more details, see <a class="reference internal" href="#finding-imports"><span class="std std-ref">How imports are found</span></a>.</p>
</li>
<li><p class="first">Third, you can use the <code class="docutils literal notranslate"><span class="pre">-p</span></code> (long form: <code class="docutils literal notranslate"><span class="pre">--package</span></code>) flag to
specify a package to be (recursively) type checked. This flag
is almost identical to the <code class="docutils literal notranslate"><span class="pre">-m</span></code> flag except that if you give it
a package name, mypy will recursively type check all submodules
and subpackages of that package. For example, running:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>$ mypy -p html
</pre></div>
</div>
<p>…will type check the entire <code class="docutils literal notranslate"><span class="pre">html</span></code> package (of library stubs).
In contrast, if we had used the <code class="docutils literal notranslate"><span class="pre">-m</span></code> flag, mypy would have type
checked just <code class="docutils literal notranslate"><span class="pre">html</span></code>’s <code class="docutils literal notranslate"><span class="pre">__init__.py</span></code> file and anything imported
from there.</p>
<p>Note that we can specify multiple packages and modules on the
command line. For example:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>$ mypy --package p.a --package p.b --module c
</pre></div>
</div>
</li>
<li><p class="first">Fourth, you can also instruct mypy to directly type check small
strings as programs by using the <code class="docutils literal notranslate"><span class="pre">-c</span></code> (long form: <code class="docutils literal notranslate"><span class="pre">--command</span></code>)
flag. For example:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>$ mypy -c &#39;x = [1, 2]; print(x())&#39;
</pre></div>
</div>
<p>…will type check the above string as a mini-program (and in this case,
will report that <code class="docutils literal notranslate"><span class="pre">List[int]</span></code> is not callable).</p>
</li>
</ol>
</div>
<div class="section" id="reading-a-list-of-files-from-a-file">
<h2>Reading a list of files from a file<a class="headerlink" href="#reading-a-list-of-files-from-a-file" title="Permalink to this headline">¶</a></h2>
<p>Finally, any command-line argument starting with <code class="docutils literal notranslate"><span class="pre">&#64;</span></code> reads additional
command-line arguments from the file following the <code class="docutils literal notranslate"><span class="pre">&#64;</span></code> character.
This is primarily useful if you have a file containing a list of files
that you want to be type-checked: instead of using shell syntax like:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>$ mypy $(cat file_of_files.txt)
</pre></div>
</div>
<p>you can use this instead:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>$ mypy @file_of_files.txt
</pre></div>
</div>
<p>This file can technically also contain any command line flag, not
just file paths. However, if you want to configure many different
flags, the recommended approach is to use a
<a class="reference internal" href="config_file.html#config-file"><span class="std std-ref">configuration file</span></a> instead.</p>
</div>
<div class="section" id="how-mypy-handles-imports">
<h2>How mypy handles imports<a class="headerlink" href="#how-mypy-handles-imports" title="Permalink to this headline">¶</a></h2>
<p>When mypy encounters an <code class="docutils literal notranslate"><span class="pre">import</span></code> statement, it will first
<a class="reference internal" href="#finding-imports"><span class="std std-ref">attempt to locate</span></a> that module
or type stubs for that module in the file system. Mypy will then
type check the imported module. There are three different outcomes
of this process:</p>
<ol class="arabic simple">
<li>Mypy is unable to follow the import: the module either does not
exist, or is a third party library that does not use type hints.</li>
<li>Mypy is able to follow and type check the import, but you did
not want mypy to type check that module at all.</li>
<li>Mypy is able to successfully both follow and type check the
module, and you want mypy to type check that module.</li>
</ol>
<p>The third outcome is what mypy will do in the ideal case. The following
sections will discuss what to do in the other two cases.</p>
<div class="section" id="missing-imports">
<span id="ignore-missing-imports"></span><h3>Missing imports<a class="headerlink" href="#missing-imports" title="Permalink to this headline">¶</a></h3>
<p>When you import a module, mypy may report that it is unable to
follow the import.</p>
<p>This could happen if the code is importing a non-existent module
or if the code is importing a library that does not use type hints.
Specifically, the library is neither declared to be a
<a class="reference internal" href="installed_packages.html#installed-packages"><span class="std std-ref">PEP 561 compliant package</span></a> nor has registered
any stubs on <a class="reference external" href="https://github.com/python/typeshed">typeshed</a>, the
repository of stubs for the standard library and popular 3rd party libraries.</p>
<p>This can cause a lot of errors that look like the following:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">main</span><span class="o">.</span><span class="n">py</span><span class="p">:</span><span class="mi">1</span><span class="p">:</span> <span class="n">error</span><span class="p">:</span> <span class="n">No</span> <span class="n">library</span> <span class="n">stub</span> <span class="n">file</span> <span class="k">for</span> <span class="n">standard</span> <span class="n">library</span> <span class="n">module</span> <span class="s1">&#39;antigravity&#39;</span>
<span class="n">main</span><span class="o">.</span><span class="n">py</span><span class="p">:</span><span class="mi">2</span><span class="p">:</span> <span class="n">error</span><span class="p">:</span> <span class="n">No</span> <span class="n">library</span> <span class="n">stub</span> <span class="n">file</span> <span class="k">for</span> <span class="n">module</span> <span class="s1">&#39;flask&#39;</span>
<span class="n">main</span><span class="o">.</span><span class="n">py</span><span class="p">:</span><span class="mi">3</span><span class="p">:</span> <span class="n">error</span><span class="p">:</span> <span class="n">Cannot</span> <span class="n">find</span> <span class="n">module</span> <span class="n">named</span> <span class="s1">&#39;this_module_does_not_exist&#39;</span>
</pre></div>
</div>
<p>If the module genuinely does not exist, you should of course fix the
import statement. If the module is a module within your codebase that mypy
is somehow unable to discover, we recommend reading the <a class="reference internal" href="#finding-imports"><span class="std std-ref">How imports are found</span></a>
section below to help you debug the issue.</p>
<p>If the module is a library that does not use type hints, the easiest fix
is to silence the error messages by adding a <code class="docutils literal notranslate"><span class="pre">#</span> <span class="pre">type:</span> <span class="pre">ignore</span></code> comment on
each respective import statement.</p>
<p>If you have many of these errors from a specific library, it may be more
convenient to silence all of those errors at once using the
<a class="reference internal" href="config_file.html#config-file"><span class="std std-ref">mypy config file</span></a>. For example, suppose your codebase
makes heavy use of an (untyped) library named <cite>foobar</cite>. You can silence all
import errors associated with that library and that library alone by adding
the following section to your config file:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="p">[</span><span class="n">mypy</span><span class="o">-</span><span class="n">foobar</span><span class="p">]</span>
<span class="n">ignore_missing_imports</span> <span class="o">=</span> <span class="kc">True</span>
</pre></div>
</div>
<p>Note: this option is equivalent to adding a <code class="docutils literal notranslate"><span class="pre">#</span> <span class="pre">type:</span> <span class="pre">ignore</span></code> to every
import of <code class="docutils literal notranslate"><span class="pre">foobar</span></code> in your codebase. For more information, see the
documentation about configuring
<a class="reference internal" href="config_file.html#config-file-import-discovery-per-module"><span class="std std-ref">import discovery</span></a> in config files.</p>
<p>If you would like to silence <em>all</em> missing import errors in your codebase,
you can do so by using the <code class="docutils literal notranslate"><span class="pre">--ignore-missing-imports</span></code> flag. We recommend
using this flag only as a last resort: it’s equivalent to adding a
<code class="docutils literal notranslate"><span class="pre">#</span> <span class="pre">type:</span> <span class="pre">ignore</span></code> to all unresolved imports in your codebase.</p>
<p>A more involved solution would be to reverse-engineer how the library
works, create type hints for the library, and point mypy at those
type hints either by passing in in via the command line or by adding
the location of your custom stubs to either the <code class="docutils literal notranslate"><span class="pre">MYPYPATH</span></code> environment
variable or the <code class="docutils literal notranslate"><span class="pre">mypy_path</span></code>
<a class="reference internal" href="config_file.html#config-file-import-discovery-global"><span class="std std-ref">config file option</span></a>.</p>
<p>If you want to share your work, you can try contributing your stubs back
to the library – see our documentation on creating
<a class="reference internal" href="installed_packages.html#installed-packages"><span class="std std-ref">PEP 561 compliant packages</span></a>.</p>
</div>
<div class="section" id="following-imports">
<span id="follow-imports"></span><h3>Following imports<a class="headerlink" href="#following-imports" title="Permalink to this headline">¶</a></h3>
<p>Mypy is designed to <a class="reference internal" href="#finding-imports"><span class="std std-ref">doggedly follow all imports</span></a>,
even if the imported module is not a file you explicitly wanted mypy to check.</p>
<p>For example, suppose we have two modules <code class="docutils literal notranslate"><span class="pre">mycode.foo</span></code> and <code class="docutils literal notranslate"><span class="pre">mycode.bar</span></code>:
the former has type hints and the latter does not. We run
<code class="docutils literal notranslate"><span class="pre">mypy</span> <span class="pre">-m</span> <span class="pre">mycode.foo</span></code> and mypy discovers that <code class="docutils literal notranslate"><span class="pre">mycode.foo</span></code> imports
<code class="docutils literal notranslate"><span class="pre">mycode.bar</span></code>.</p>
<p>How do we want mypy to type check <code class="docutils literal notranslate"><span class="pre">mycode.bar</span></code>? We can configure the
desired behavior by using the <code class="docutils literal notranslate"><span class="pre">--follow-imports</span></code> flag. This flag
accepts one of four string values:</p>
<ul>
<li><p class="first"><code class="docutils literal notranslate"><span class="pre">normal</span></code> (the default) follows all imports normally and
type checks all top level code (as well as the bodies of all
functions and methods with at least one type annotation in
the signature).</p>
</li>
<li><p class="first"><code class="docutils literal notranslate"><span class="pre">silent</span></code> behaves in the same way as <code class="docutils literal notranslate"><span class="pre">normal</span></code> but will
additionally <em>suppress</em> any error messages.</p>
</li>
<li><p class="first"><code class="docutils literal notranslate"><span class="pre">skip</span></code> will <em>not</em> follow imports and instead will silently
replace the module (and <em>anything imported from it</em>) with an
object of type <code class="docutils literal notranslate"><span class="pre">Any</span></code>.</p>
<p>(Note: this option used to be known as <code class="docutils literal notranslate"><span class="pre">--silent-imports</span></code>.)</p>
</li>
<li><p class="first"><code class="docutils literal notranslate"><span class="pre">error</span></code> behaves in the same way as <code class="docutils literal notranslate"><span class="pre">skip</span></code> but is not quite as
silent – it will flag the import as an error, like this:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">main</span><span class="o">.</span><span class="n">py</span><span class="p">:</span><span class="mi">1</span><span class="p">:</span> <span class="n">note</span><span class="p">:</span> <span class="n">Import</span> <span class="n">of</span> <span class="s1">&#39;mycode.bar&#39;</span> <span class="n">ignored</span>
<span class="n">main</span><span class="o">.</span><span class="n">py</span><span class="p">:</span><span class="mi">1</span><span class="p">:</span> <span class="n">note</span><span class="p">:</span> <span class="p">(</span><span class="n">Using</span> <span class="o">--</span><span class="n">follow</span><span class="o">-</span><span class="n">imports</span><span class="o">=</span><span class="n">error</span><span class="p">,</span> <span class="n">module</span> <span class="ow">not</span> <span class="n">passed</span> <span class="n">on</span> <span class="n">command</span> <span class="n">line</span><span class="p">)</span>
</pre></div>
</div>
</li>
</ul>
<p>If you are starting a new codebase and plan on using type hints from
the start, we recommend you use either <code class="docutils literal notranslate"><span class="pre">--follow-imports=normal</span></code>
(the default) or <code class="docutils literal notranslate"><span class="pre">--follow-imports=error</span></code>. Either option will help
make sure you are not skipping checking any part of your codebase by
accident.</p>
<p>If you are planning on adding type hints to a large, existing code base,
we recommend you start by trying to make your entire codebase (including
files that do not use type hints) pass under <code class="docutils literal notranslate"><span class="pre">--follow-imports=normal</span></code>.
This is usually not too difficult to do: mypy is designed to report as
few error messages as possible when it is looking at unannotated code.</p>
<p>If doing this is intractable, we recommend passing mypy just the files
you want to type check and use <code class="docutils literal notranslate"><span class="pre">--follow-imports=silent</span></code>. Even if
mypy is unable to perfectly type check a file, it can still glean some
useful information by parsing it (for example, understanding what methods
a given object has). See <a class="reference internal" href="existing_code.html#existing-code"><span class="std std-ref">Using mypy with an existing codebase</span></a> for more recommendations.</p>
<p>We do not recommend using <code class="docutils literal notranslate"><span class="pre">skip</span></code> unless you know what you are doing:
while this option can be quite powerful, it can also cause many
hard-to-debug errors.</p>
</div>
</div>
<div class="section" id="mapping-file-paths-to-modules">
<span id="mapping-paths-to-modules"></span><h2>Mapping file paths to modules<a class="headerlink" href="#mapping-file-paths-to-modules" title="Permalink to this headline">¶</a></h2>
<p>One of the main ways you can tell mypy what files to type check
is by providing mypy the paths to those files. For example:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>$ mypy file_1.py foo/file_2.py file_3.pyi some/directory
</pre></div>
</div>
<p>This section describes how exactly mypy maps the provided paths
to modules to type check.</p>
<ul class="simple">
<li>Files ending in <code class="docutils literal notranslate"><span class="pre">.py</span></code> (and stub files ending in <code class="docutils literal notranslate"><span class="pre">.pyi</span></code>) are
checked as Python modules.</li>
<li>Files not ending in <code class="docutils literal notranslate"><span class="pre">.py</span></code> or <code class="docutils literal notranslate"><span class="pre">.pyi</span></code> are assumed to be Python
scripts and checked as such.</li>
<li>Directories representing Python packages (i.e. containing a
<code class="docutils literal notranslate"><span class="pre">__init__.py[i]</span></code> file) are checked as Python packages; all
submodules and subpackages will be checked (subpackages must
themselves have a <code class="docutils literal notranslate"><span class="pre">__init__.py[i]</span></code> file).</li>
<li>Directories that don’t represent Python packages (i.e. not directly
containing an <code class="docutils literal notranslate"><span class="pre">__init__.py[i]</span></code> file) are checked as follows:<ul>
<li>All <code class="docutils literal notranslate"><span class="pre">*.py[i]</span></code> files contained directly therein are checked as
toplevel Python modules;</li>
<li>All packages contained directly therein (i.e. immediate
subdirectories with an <code class="docutils literal notranslate"><span class="pre">__init__.py[i]</span></code> file) are checked as
toplevel Python packages.</li>
</ul>
</li>
</ul>
<p>One more thing about checking modules and packages: if the directory
<em>containing</em> a module or package specified on the command line has an
<code class="docutils literal notranslate"><span class="pre">__init__.py[i]</span></code> file, mypy assigns these an absolute module name by
crawling up the path until no <code class="docutils literal notranslate"><span class="pre">__init__.py[i]</span></code> file is found.</p>
<p>For example, suppose we run the command <code class="docutils literal notranslate"><span class="pre">mypy</span> <span class="pre">foo/bar/baz.py</span></code> where
<code class="docutils literal notranslate"><span class="pre">foo/bar/__init__.py</span></code> exists but <code class="docutils literal notranslate"><span class="pre">foo/__init__.py</span></code> does not.  Then
the module name assumed is <code class="docutils literal notranslate"><span class="pre">bar.baz</span></code> and the directory <code class="docutils literal notranslate"><span class="pre">foo</span></code> is
added to mypy’s module search path.</p>
<p>On the other hand, if <code class="docutils literal notranslate"><span class="pre">foo/bar/__init__.py</span></code> did not exist, <code class="docutils literal notranslate"><span class="pre">foo/bar</span></code>
would be added to the module search path instead, and the module name
assumed is just <code class="docutils literal notranslate"><span class="pre">baz</span></code>.</p>
<p>If a script (a file not ending in <code class="docutils literal notranslate"><span class="pre">.py[i]</span></code>) is processed, the module
name assumed is <code class="docutils literal notranslate"><span class="pre">__main__</span></code> (matching the behavior of the
Python interpreter), unless <code class="docutils literal notranslate"><span class="pre">--scripts-are-modules</span></code> is passed.</p>
</div>
<div class="section" id="how-imports-are-found">
<span id="finding-imports"></span><h2>How imports are found<a class="headerlink" href="#how-imports-are-found" title="Permalink to this headline">¶</a></h2>
<p>When mypy encounters an <code class="docutils literal notranslate"><span class="pre">import</span></code> statement or receives module
names from the command line via the <code class="docutils literal notranslate"><span class="pre">--module</span></code> or <code class="docutils literal notranslate"><span class="pre">--package</span></code>
flags, mypy tries to find the module on the file system similar
to the way Python finds it. However, there are some differences.</p>
<p>First, mypy has its own search path.
This is computed from the following items:</p>
<ul class="simple">
<li>The <code class="docutils literal notranslate"><span class="pre">MYPYPATH</span></code> environment variable
(a colon-separated list of directories).</li>
<li>The <code class="docutils literal notranslate"><span class="pre">mypy_path</span></code> <a class="reference internal" href="config_file.html#config-file-import-discovery-global"><span class="std std-ref">config file option</span></a>.</li>
<li>The directories containing the sources given on the command line
(see below).</li>
<li>The installed packages marked as safe for type checking (see
<a class="reference internal" href="installed_packages.html#installed-packages"><span class="std std-ref">PEP 561 support</span></a>)</li>
<li>The relevant directories of the
<a class="reference external" href="https://github.com/python/typeshed">typeshed</a> repo.</li>
</ul>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">You cannot point to a PEP 561 package via the MYPYPATH, it must be
installed (see <a class="reference internal" href="installed_packages.html#installed-packages"><span class="std std-ref">PEP 561 support</span></a>)</p>
</div>
<p>For sources given on the command line, the path is adjusted by crawling
up from the given file or package to the nearest directory that does not
contain an <code class="docutils literal notranslate"><span class="pre">__init__.py</span></code> or <code class="docutils literal notranslate"><span class="pre">__init__.pyi</span></code> file.</p>
<p>Second, mypy searches for stub files in addition to regular Python files
and packages.
The rules for searching for a module <code class="docutils literal notranslate"><span class="pre">foo</span></code> are as follows:</p>
<ul class="simple">
<li>The search looks in each of the directories in the search path
(see above) until a match is found.</li>
<li>If a package named <code class="docutils literal notranslate"><span class="pre">foo</span></code> is found (i.e. a directory
<code class="docutils literal notranslate"><span class="pre">foo</span></code> containing an <code class="docutils literal notranslate"><span class="pre">__init__.py</span></code> or <code class="docutils literal notranslate"><span class="pre">__init__.pyi</span></code> file)
that’s a match.</li>
<li>If a stub file named <code class="docutils literal notranslate"><span class="pre">foo.pyi</span></code> is found, that’s a match.</li>
<li>If a Python module named <code class="docutils literal notranslate"><span class="pre">foo.py</span></code> is found, that’s a match.</li>
</ul>
<p>These matches are tried in order, so that if multiple matches are found
in the same directory on the search path
(e.g. a package and a Python file, or a stub file and a Python file)
the first one in the above list wins.</p>
<p>In particular, if a Python file and a stub file are both present in the
same directory on the search path, only the stub file is used.
(However, if the files are in different directories, the one found
in the earlier directory is used.)</p>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <h3><a href="index.html">Table Of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">Running mypy and managing imports</a><ul>
<li><a class="reference internal" href="#specifying-code-to-be-checked">Specifying code to be checked</a></li>
<li><a class="reference internal" href="#reading-a-list-of-files-from-a-file">Reading a list of files from a file</a></li>
<li><a class="reference internal" href="#how-mypy-handles-imports">How mypy handles imports</a><ul>
<li><a class="reference internal" href="#missing-imports">Missing imports</a></li>
<li><a class="reference internal" href="#following-imports">Following imports</a></li>
</ul>
</li>
<li><a class="reference internal" href="#mapping-file-paths-to-modules">Mapping file paths to modules</a></li>
<li><a class="reference internal" href="#how-imports-are-found">How imports are found</a></li>
</ul>
</li>
</ul>

  <h4>Previous topic</h4>
  <p class="topless"><a href="metaclasses.html"
                        title="previous chapter">Metaclasses</a></p>
  <h4>Next topic</h4>
  <p class="topless"><a href="command_line.html"
                        title="next chapter">The mypy command line</a></p>
  <div role="note" aria-label="source link">
    <h3>This Page</h3>
    <ul class="this-page-menu">
      <li><a href="_sources/running_mypy.rst.txt"
            rel="nofollow">Show Source</a></li>
    </ul>
   </div>
<div id="searchbox" style="display: none" role="search">
  <h3>Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    </div>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="command_line.html" title="The mypy command line"
             >next</a> |</li>
        <li class="right" >
          <a href="metaclasses.html" title="Metaclasses"
             >previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="index.html">Mypy 0.630+dev-734a166d380bfb0de05ce0e3c61dc7e675898e9c-dirty documentation</a> &#187;</li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
        &#169; Copyright 2016, Jukka Lehtosalo.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.7.5.
    </div>
  </body>
</html>