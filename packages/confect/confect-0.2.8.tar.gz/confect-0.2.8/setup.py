# -*- coding: utf-8 -*-
from distutils.core import setup

packages = \
['confect']

package_data = \
{'': ['*']}

setup_kwargs = {
    'name': 'confect',
    'version': '0.2.8',
    'description': 'a Python configuration library loads Python configuration files',
    'long_description': "Confect - a Python configuration library loads Python configuration files\n=============================================================================\n\nWhy you need a configuration library?\n-------------------------------------\n\n\n- You have a project that needs to access database or other services with password or some secret keys. \n  Storing secrets and passwords in your code is not smart. \n  You need a configuration file and a library for loading and using it.\n\n- Your project runs in different environments. \n  For example, database IP addresses and passwords in development environment normally differs from production environment. \n  You need multiple configuration files for storing those information for different environment, and load one of them in the run time.\n  \n- You're doing some experiments, e.g. Machine Learning projects. \n  There're a bunch of parameters needs to be changed in the run time. \n  And you want to manage them in a smarter and more elegant way.\n\nHow confect differs from others?\n-------------------------------------\n\n- loads Python configuration files. This makes it possible to\n\n  + have complex type objects as configuration values, like Decimal, timedelta\n    or any class instance\n  + dynamically handle complicated logic, you can use conditional statements\n    like ``if`` in it.\n  + read other TOML/YMAL/JSON/ini files or even environment variables in the\n    configuration file.\n\n- supports multiple configuration file loading ways and can load multiple times.\n  It loads configuration file through a given file path, or through module importing. \n- loads configurations properties from environment variable. \n  It's convenient if you want to change single or some properties values and don't want to modify the configuration file.\n- forces users to predefine configuration properties for readability and maintainability.\n- Immutable conf object for reducing the possibility of making errors. \n  No one should modify configuration too dynamically as if they are global variables.\n- A readable and pleasant accessing interface\n    \n\nInstall\n========\n\n``confect`` is a Python package hosted on PyPI and works only with Python 3.6 up.\n\nJust like other Python packages, install it by `pip\n<https://pip.pypa.io/en/stable/>`_ into a `virtualenv\n<https://hynek.me/articles/virtualenv-lives/>`_, or use `poetry\n<https://poetry.eustace.io/>`_ to manage project dependencies and virtualenv.\n\n.. code:: console\n\n   $ pip install confect\n\n\nBasic Usage\n===========\n\nInitialize Conf object\n----------------------\n\nCalling ``conf = confect.Conf()`` creates a new configuration manager object.\n\nFor example, suppose ``proj_X`` is your top-level package name. \nPut the following lines into ``proj_X/core.py``.\n\n.. code:: python\n\n   import confect\n   conf = confect.Conf()\n\n   # load configuration files through importing\n   try:\n       conf.load_module('proj_X_conf')\n   except ImportError:\n       pass\n\n   # overrides configuration with environment variables with the prefix `proj_X`\n   conf.load_envvars('proj_X')\n   \nAnd import the ``conf`` object module in any other module\n\n.. code:: python\n\n   from proj_X.core import conf\n\nIt is possible to create multiple ``Conf`` objects, but normally you don't need\nit. In most cases, initialize only one ``Conf`` object in one module of your\npackage, then import and use it anywhere in your application.\n\nUse ``PYTHONPATH`` environment varibale to control the source of configuration file.\n\n.. code:: console\n\n   $ vi proj_X_conf.py\n   $ export PYTHONPATH=.\n   $ python your_application.py\n\nDeclare Configuration Groups and Properties\n-------------------------------------------\n\n**Configuration properties should be declared before using it.** This feature makes \nyour code more readable and maintainable. Default values of all properties\nshould be defined along with the configuration declaration. \nIt doesn't have to be a workable value\n(like some secret keys or passwords you shouldn't put it in the code), \nthe true workable value can be defined \nin the configuration file. \nHowever, even if it's not a workable value, \nthe mock default values still makes the declaration and the code more readable.\n\nUse ``Conf.declare_group(group_name)`` context manager to declare a configuration\ngroup and all properties and default values under it at the same time. \nDefault values can be any type. The group name should be a valid attribute name.\n\nPut your configuration group declaration code in the module where you need those\nproperties. And make sure that the declaration is before all the lines that\naccess these properties, or it would raise exceptions.\nNormally, the group name is your class name, module name or subpackage name.\n\nSuppose that there's a ``proj_X/api.py`` module for http API service. \nWe declared a new configuration group named of ``api``. \nAnd we need three configuration properties for the API service, \n``cache_expire``, ``cache_prefix`` and ``url_base_path``.\n\n.. code:: python\n   :number-lines: 1\n\n   from proj_X.core import conf\n\n   with conf.declare_group('api') as cg: # `cg` stands for conf_group\n       cg.cache_expire = 60 * 60 * 24\n       cg.cache_prefix = 'proj_X_cache'\n       cg.url_base_path = 'api/v2/'\n\nAccess Configuration\n--------------------\n\nAfter the group and properties are declared, they are accessable through\ngetting attribute from the ``Conf`` object, like this ``conf.group_name.prop_name``.\n\nHere's the rest of ``proj_X/api.py`` module for demostrating how to access configurations.\n\n.. code:: python\n   :number-lines: 9\n\n   @routes(conf.api.url_base_path + 'add')\n   @redis_cache(key=conf.api.cache_prefix, expire=conf.api.cache_expire)\n   def add(a, b)\n       return a + b\n\n\n**Configuration properties and groups are immutable.** They can only be globally\nchanged by loading configuration files. Otherwise, they are always default\nvalues.\n\n>>> conf.api.cache_expire = 60 * 60 * 3\nTraceback (most recent call last):\n   ...\nconfect.error.FrozenConfPropError: Configuration properties are frozen.\n\nConfiguration File\n------------------\n\nConfect loads configuration files is in Python. That makes your configuration file\nprogrammable and unrestricted as we described in the section `How confect differs from others?`_.\n\nIt's not necessary and is unusual to have all configuration properties be defined in the\nconfiguration file. *Put only those configuration properties and corresponding\nvalues that you want to override to the configuration file.*\n\nIn configuration file, import ``confect.c`` object and set all properties on it\nas if ``c`` is the conf object. Here's an example of configuration file.\n\n.. code-block:: python\n\n   from confect import c\n\n   c.yummy.kind = 'poultry'\n   c.yummy.name = 'chicken'\n   c.yummy.weight = 25\n\n   import os\n   # simple calculation or loading env var\n   c.cache.expire = 60 * 60 # one hour\n   c.cache.key = os.environ['CACHE_KEY']\n\n   # it's easy to have conditional statement\n   DEBUG = True\n   if DEBUG:\n       c.cache.disable = True\n\n   # loading some secret file and set configuration\n   import json\n   with open('secret.json') as f:\n       secret = json.load(f)\n\n   c.secret.key = secret['key']\n   c.secret.token = secret['token']\n\nThe ``c`` object only exits when loading a python configuration file, it's not\npossible to import it in your source code. You can set any property in any\nconfiguration group onto the ``c`` object. However,\n**they are only accessable if you declared it in the source code with** ``Conf.declare_group(group_name)``.\n\n\nAdvanced Usage\n==============\n\nLoading Configuration\n---------------------\n\nConfiguration properties and groups are immutable. The standard way to change it\nis to load configuration from files or environment variables.\n\nUse ``Conf.load_conf_file(path)`` or ``Conf.load_conf_module(module_name)`` to\nload configuration files, or use ``Conf.load_envvars(prefix)`` to load\nconfiguration from environment variable. No matter the loading statement is\nlocated before or after groups/properties declaration, property values in\nconfiguration file always override default values. It's possible to load \nconfiguration multiple times, the latter one would replace values from former loading.\n\nBe aware, *you should access your configuration properties after load\nconfiguration files.* If not, you might get wrong/default value. Therefore, we\nusually load configuration file right after the statement of creating the\n``Conf`` object.\n\nThe code in the section `Initialize Conf object`_ is a simple example that loads only through module importing. \nHere's an much more complex example that demostrates how to dynamically select and load configurations.\n\n.. code:: python\n\n   import sys\n   import confect\n\n   conf = confect.Conf()\n\n   # load configuration file\n   if len(sys.argv) == 2:\n       conf.load_conf_file(sys.argv[1])\n   else:\n       try:\n          conf.load_conf_file('path/to/team_conf.py')\n       FileNotFoundError:\n          logger.warning('Unable to find team configuration file')\n\n       try:\n          conf.load_conf_file('path/to/personal_conf.py')\n       FileNotFoundError:\n          logger.info('Unable to find personal configuration file')\n\n   # load configuration file through importing\n   try:\n       conf.load_module('proj_X_conf')\n   except ImportError:\n       logger.warning('Unable to load find configuration module %r',\n                      'proj_x_conf')\n\n   # overrides configuration with environment variables\n   conf.load_envvars('proj_X')\n\n\nLoad Environment Variables\n---------------------------\n\n``Conf.load_envvars(prefix: str)`` automatically searches environment variables\nin ``<prefix>__<group>__<prop>`` format. All of these three identifier are case\nsensitive. If you have a configuration property ``conf.cache.expire_time`` and\nyou call ``Conf.load_envvars('proj_X')``. It will set that ``expire_time``\nproperty to the parsed value of ``proj_X__cache__expire_time`` environment\nvariable.\n\n>>> import os\n>>> os.environ['proj_X__cache__expire'] = '3600'\n\n>>> conf = confect.Conf()\n>>> conf.load_envvars('proj_X')  # doctest: +SKIP\n\nIf ``cache.expire`` has been declared, then\n\n>>> conf.cache.expire\n3600\n\nConfect includes predefined parsers of these primitive types.\n\n- ``str``: ``s``\n- ``int``: ``int(s)``\n- ``float``: ``float(s)``\n- ``bytes``: ``s.decode()``\n- ``datetime.datetime`` : ``pendulum.parse(s)``\n- ``datetime.date`` : ``pendulum.parse(s).date()``\n- ``Decimal`` : ``decimal.Decimal(s)``\n- ``tuple`` : ``json.loads(s)``\n- ``dict``: ``json.loads(s)``\n- ``list``: ``json.loads(s)``\n\nMutable Environment\n-----------------\n\n``Conf.mutate_locally()`` context manager creates an environment that makes\n``Conf`` object temporarily mutable. All changes would be restored when it\nleaves the block. It is usaful on writing test case or testing configuration\nproperties in Python REPL.\n\n>>> conf = Conf()\n>>> conf.declare_group(  # declare group through keyword arguments\n...      'dummy',\n...      prop1=3,\n...      prop2='some string')\n...\n>>> with conf.mutate_locally():\n...      conf.dummy.prop1 = 5\n...      print(conf.dummy.prop1)\n5\n...     call_some_function_use_this_property()\n>>> print(conf.dummy.prop1)  # all configuration restored\n3\n\n\nTo-Dos\n======\n\n- A function for loading dictionary into ``conflect.c``.\n- A function that loads command line arguments and overrides configuration properties.\n- Copy-on-write mechenism in ``conf.mutate_locally()`` for better performance and memory usage.\n- API reference page\n",
    'author': '顏孜羲',
    'author_email': 'joseph.yen@gmail.com',
    'url': 'https://github.com/d2207197/confect',
    'packages': packages,
    'package_data': package_data,
    'python_requires': '>=3.6,<4.0',
}


setup(**setup_kwargs)
