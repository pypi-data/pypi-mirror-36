#!/usr/bin/python
# -*- coding: utf-8 -*-
# TODO use swagger based autogenerated library for implementing these functions
# TODO use colors for heading and contests
from ...models import Judge
from ...utils.logging import logger
import click
import requests
import json
from .utils import get_data, login_oauth
from beautifultable import BeautifulTable
from ...utils.Errors import AuthenticationError
from .models import Problem, Contest, Testcase
from ...utils import style


class Codechef(Judge):
    def __init__(self, session_data=None):
        logger.debug("Initializing class Codechef with session_data:\n%s"
                     % session_data)
        self.name = "codechef"
        self.url = "https://www.codechef.com"
        self.api_url = "https://api.codechef.com"
        self.session_data = session_data
        if(session_data is not None):
            self._update_session()

    def check_login(self):
        logger.debug("Checking Login")
        if(self.session is None):
            logger.debug("No session object initialized")
            return False
        me_url = self._make_url(self.api_url, 'users/me')
        try:
            r = self._request_api(me_url)
            logger.debug(r)
            return True
        except requests.RequestException:
            return False

    def login(self):
        token = login_oauth()
        self.session_data = token
        self._update_session()
        assert(self.check_login())

    def logout(self):
        logger.warning("Logout of CodeChef.")
        click.confirm("Are you sure?", default=True, abort=True)
        self.session_data = None

    def get_running_contests(self):
        logger.debug('get running contests')
        contests = get_data.running_contests(self)
        table = BeautifulTable()
        table.width_exceed_policy = BeautifulTable.WEP_WRAP
        # TODO: use map style.headers instead of str
        # requires change with beautifultable. we may try dev version
        # TODO: sort running and upcoming
        table.column_headers = list(
            map(style.header, ['code', 'name', 'end', 'start']))
        for contest in contests:
            table.append_row(
                [
                    contest['code'], contest['name'],
                    str(contest['startDate']), str(contest['endDate'])
                ]
            )
        return table

    def get_problem(self, problem_code, contest_code):
        logger.info('fetching problem %s' % problem_code)
        if(problem_code is not None):
            if(contest_code is None):
                contest_code = 'PRACTICE'
            contest_code = contest_code.upper()
            problem_code = problem_code.upper()
            problem_url = self._make_url(
                self.api_url, 'contests', contest_code, 'problems', problem_code)
            problem_data = self._request_api(problem_url)
            problem = Problem(data=problem_data)
            problem.judge_name = self.name
            problem.contest_code = contest_code
            return problem

    def get_contest(self, contest_code):
        logger.info('fetching contest %s' % contest_code)
        contest_code = contest_code.upper()
        contest_url = self._make_url(self.api_url, 'contests', contest_code)
        contest_data = self._request_api(contest_url)
        contest = Contest(data=contest_data)
        logger.debug(contest.problem_codes)
        for problem_code in contest.problem_codes:
            contest.problems.append(
                self.get_problem(
                    contest_code=contest.code, problem_code=problem_code))
        contest.judge_name = self.name
        return contest

    def get_problem_url(self, problem_code, contest_code):
        if (contest_code is None):
            contest_code = 'PRACTICE'
        contest_code = contest_code.upper()
        problem_code = problem_code.upper()
        if(contest_code == 'PRACTICE'):
            return self._make_url(self.url, 'problems', problem_code)
        return self._make_url(self.url, contest_code,
                              'problems', problem_code)

    def submit(self, problem, code_text, extension):
        # TODO : correct this
        logger.warn("Codechef api doesn't support the submissions yet.\n"
                    "Please contact them to support this.\n"
                    "You can also try codechef-web implementation.\n"
                    "https://github.com/termicoder/termicoder-codechef-web\n"
        )
        import pyperclip
        pyperclip.copy(code_text)
        if(problem.contest_code != 'PRACTICE'):
            url = self._make_url(
                self.url, problem.contest_code, 'submit', problem.code)
        else:
            url = self._make_url(
                self.url, 'submit', problem.code)
        logger.warn("By the time,"
                    "We have copied the code to clipboard "
                    "and are launching the submit url\n%s\n"
                    "Please paste your code there and submit" % url)
        click.confirm("Continue?", default=True)
        click.launch(url)

    def get_contest_url(self, contest_code):
        if (contest_code is None):
            contest_code = 'PRACTICE'
        contest_code = contest_code.upper()
        if(contest_code == 'PRACTICE'):
            return self._make_url(self.url, 'problems', 'school')
        return self._make_url(self.url, contest_code)

    def get_contests_list_url(self):
        return self._make_url(self.url, 'contests')

    def _update_session(self):
        self.session = requests.Session()

        def debug_url(r, *args, **kwargs):
            logger.debug('Getting url %s' % r.url)

        def debug_data(r, *args, **kwargs):
            try:
                response = json.dumps(r.json(), indent=1)
            except json.JSONDecodeError:
                response = r.text
            logger.debug('Response %s' % response)

        self.session.hooks['response'].append(debug_url)
        self.session.hooks['response'].append(debug_data)
        token = self.session_data['result']['data']['access_token']
        logger.debug('Token: ' + token)
        OAuth2_Header = {
            'Authorization': 'Bearer %s' % token
        }
        self.session.headers.update(OAuth2_Header)

    def get_testcase(self, inp, ans, code):
        return Testcase(inp=inp, ans=ans, code=code)

    def _make_url(self, base_url, *rel_urls):
        logger.debug(base_url)
        logger.debug(rel_urls)
        base_url = base_url.strip('/')
        join_urls = [base_url]
        for rel_url in rel_urls:
            join_urls.append(rel_url.strip('/'))
        return "/".join(join_urls)

    def _request_api(self, url):
        logger.debug('fetching url %s' % url)
        try:
            with self.session as s:
                r = s.get(url)
                logger.debug(r)
                r.raise_for_status()
            return r.json()
        except AttributeError:
            raise AuthenticationError(
                'The endpoint %s requires authorization\n'
                'Try `termicoder setup --login -j codechef` first'
                'and grant appropriate rights' % url)

    def _refresh_token(self):
        logger.debug('refreshing token')
        url = 'http://termicoder.diveshuttam.me/refresh_token/'
        raise NotImplementedError
        # TODO implement this on server side
        r = requests.get(url, data=self.session_data)
        logger.debug(r.json())
