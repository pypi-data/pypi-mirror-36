# ----------------------------------------------------------------------
# Numenta Platform for Intelligent Computing (NuPIC)
# Copyright (C) 2013-2017, Numenta, Inc.  Unless you have an agreement
# with Numenta, Inc., for a separate license for this software code, the
# following terms and conditions apply:
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU Affero Public License version 3 as
# published by the Free Software Foundation.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
# See the GNU Affero Public License for more details.
#
# You should have received a copy of the GNU Affero Public License
# along with this program.  If not, see http://www.gnu.org/licenses.
#
# http://numenta.org/licenses/
# ----------------------------------------------------------------------

# This file was automatically generated by SWIG (http://www.swig.org).
# Version 3.0.2
#
# Do not make changes to this file unless you know what you are doing--modify
# the SWIG interface file instead.





from sys import version_info
if version_info >= (2,6,0):
    def swig_import_helper():
        from os.path import dirname
        import imp
        fp = None
        try:
            fp, pathname, description = imp.find_module('_experimental', [dirname(__file__)])
        except ImportError:
            import _experimental
            return _experimental
        if fp is not None:
            try:
                _mod = imp.load_module('_experimental', fp, pathname, description)
            finally:
                fp.close()
            return _mod
    _experimental = swig_import_helper()
    del swig_import_helper
else:
    import _experimental
del version_info
try:
    _swig_property = property
except NameError:
    pass # Python < 2.2 doesn't have 'property'.
def _swig_setattr_nondynamic(self,class_type,name,value,static=1):
    if (name == "thisown"): return self.this.own(value)
    if (name == "this"):
        if type(value).__name__ == 'SwigPyObject':
            self.__dict__[name] = value
            return
    method = class_type.__swig_setmethods__.get(name,None)
    if method: return method(self,value)
    if (not static):
        self.__dict__[name] = value
    else:
        raise AttributeError("You cannot add attributes to %s" % self)

def _swig_setattr(self,class_type,name,value):
    return _swig_setattr_nondynamic(self,class_type,name,value,0)

def _swig_getattr(self,class_type,name):
    if (name == "thisown"): return self.this.own()
    method = class_type.__swig_getmethods__.get(name,None)
    if method: return method(self)
    raise AttributeError(name)

def _swig_repr(self):
    try: strthis = "proxy of " + self.this.__repr__()
    except: strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)

try:
    _object = object
    _newclass = 1
except AttributeError:
    class _object : pass
    _newclass = 0


def _swig_setattr_nondynamic_method(set):
    def set_attr(self,name,value):
        if (name == "thisown"): return self.this.own(value)
        if hasattr(self,name) or (name == "this"):
            set(self,name,value)
        else:
            raise AttributeError("You cannot add attributes to %s" % self)
    return set_attr


try:
    import weakref
    weakref_proxy = weakref.proxy
except:
    weakref_proxy = lambda x: x


import os

try:
  # NOTE need to import capnp first to activate the magic necessary for
  # ApicalTiebreakTemporalMemoryProto_capnp, etc.
  import capnp
except ImportError:
  capnp = None
else:
  from htmresearch_core.proto.ApicalTiebreakTemporalMemoryProto_capnp import (
    ApicalTiebreakTemporalMemoryProto, ApicalTiebreakSequenceMemoryProto)


_EXPERIMENTAL = _experimental


def enumerateDistantSDRsBruteForce(*args, **kwargs):
  """enumerateDistantSDRsBruteForce(n, w, threshold) -> PyObject *"""
  return _experimental.enumerateDistantSDRsBruteForce(*args, **kwargs)
import numpy

# Without this, Python scripts that haven't imported nupic.bindings.algorithms
# will get a SwigPyObject rather than a SWIG-wrapped Connections instance
# when accessing the ApicalTiebreakTemporalMemory's connections.
import nupic.bindings.algorithms


class ApicalTiebreakTemporalMemory(object):
    """Proxy of C++ nupic::experimental::apical_tiebreak_temporal_memory::ApicalTiebreakTemporalMemory class"""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(self) -> ApicalTiebreakTemporalMemory
        __init__(self, columnCount, basalInputSize, apicalInputSize, cellsPerColumn=32, activationThreshold=13, 
            initialPermanence=0.21, connectedPermanence=0.50, minThreshold=10, 
            sampleSize=20, permanenceIncrement=0.10, permanenceDecrement=0.10, basalPredictedSegmentDecrement=0.0, 
            apicalPredictedSegmentDecrement=0.0, learnOnOneCell=False, 
            seed=42, maxSegmentsPerCell=255, maxSynapsesPerSegment=255, checkInputs=True) -> ApicalTiebreakTemporalMemory
        """
        this = _experimental.new_ApicalTiebreakTemporalMemory(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _experimental.delete_ApicalTiebreakTemporalMemory
    def seed(self, *args, **kwargs):
        """seed(self, seed)"""
        return _experimental.ApicalTiebreakTemporalMemory_seed(self, *args, **kwargs)

    def reset(self):
        """reset(self)"""
        return _experimental.ApicalTiebreakTemporalMemory_reset(self)

    def createBasalSegment(self, *args, **kwargs):
        """createBasalSegment(self, cell) -> nupic::algorithms::connections::Segment"""
        return _experimental.ApicalTiebreakTemporalMemory_createBasalSegment(self, *args, **kwargs)

    def createApicalSegment(self, *args, **kwargs):
        """createApicalSegment(self, cell) -> nupic::algorithms::connections::Segment"""
        return _experimental.ApicalTiebreakTemporalMemory_createApicalSegment(self, *args, **kwargs)

    def numberOfCells(self):
        """numberOfCells(self) -> nupic::UInt"""
        return _experimental.ApicalTiebreakTemporalMemory_numberOfCells(self)

    def getActiveBasalSegments(self):
        """getActiveBasalSegments(self) -> VectorOfUInt32"""
        return _experimental.ApicalTiebreakTemporalMemory_getActiveBasalSegments(self)

    def getMatchingBasalSegments(self):
        """getMatchingBasalSegments(self) -> VectorOfUInt32"""
        return _experimental.ApicalTiebreakTemporalMemory_getMatchingBasalSegments(self)

    def getActiveApicalSegments(self):
        """getActiveApicalSegments(self) -> VectorOfUInt32"""
        return _experimental.ApicalTiebreakTemporalMemory_getActiveApicalSegments(self)

    def getMatchingApicalSegments(self):
        """getMatchingApicalSegments(self) -> VectorOfUInt32"""
        return _experimental.ApicalTiebreakTemporalMemory_getMatchingApicalSegments(self)

    def getBasalInputSize(self):
        """getBasalInputSize(self) -> nupic::UInt"""
        return _experimental.ApicalTiebreakTemporalMemory_getBasalInputSize(self)

    def getApicalInputSize(self):
        """getApicalInputSize(self) -> nupic::UInt"""
        return _experimental.ApicalTiebreakTemporalMemory_getApicalInputSize(self)

    def numberOfColumns(self):
        """numberOfColumns(self) -> nupic::UInt"""
        return _experimental.ApicalTiebreakTemporalMemory_numberOfColumns(self)

    def getCellsPerColumn(self):
        """getCellsPerColumn(self) -> nupic::UInt"""
        return _experimental.ApicalTiebreakTemporalMemory_getCellsPerColumn(self)

    def getActivationThreshold(self):
        """getActivationThreshold(self) -> nupic::UInt"""
        return _experimental.ApicalTiebreakTemporalMemory_getActivationThreshold(self)

    def setActivationThreshold(self, *args, **kwargs):
        """setActivationThreshold(self, arg2)"""
        return _experimental.ApicalTiebreakTemporalMemory_setActivationThreshold(self, *args, **kwargs)

    def getInitialPermanence(self):
        """getInitialPermanence(self) -> nupic::algorithms::connections::Permanence"""
        return _experimental.ApicalTiebreakTemporalMemory_getInitialPermanence(self)

    def setInitialPermanence(self, *args, **kwargs):
        """setInitialPermanence(self, arg2)"""
        return _experimental.ApicalTiebreakTemporalMemory_setInitialPermanence(self, *args, **kwargs)

    def getConnectedPermanence(self):
        """getConnectedPermanence(self) -> nupic::algorithms::connections::Permanence"""
        return _experimental.ApicalTiebreakTemporalMemory_getConnectedPermanence(self)

    def setConnectedPermanence(self, *args, **kwargs):
        """setConnectedPermanence(self, arg2)"""
        return _experimental.ApicalTiebreakTemporalMemory_setConnectedPermanence(self, *args, **kwargs)

    def getMinThreshold(self):
        """getMinThreshold(self) -> nupic::UInt"""
        return _experimental.ApicalTiebreakTemporalMemory_getMinThreshold(self)

    def setMinThreshold(self, *args, **kwargs):
        """setMinThreshold(self, arg2)"""
        return _experimental.ApicalTiebreakTemporalMemory_setMinThreshold(self, *args, **kwargs)

    def getSampleSize(self):
        """getSampleSize(self) -> nupic::UInt"""
        return _experimental.ApicalTiebreakTemporalMemory_getSampleSize(self)

    def setSampleSize(self, *args, **kwargs):
        """setSampleSize(self, arg2)"""
        return _experimental.ApicalTiebreakTemporalMemory_setSampleSize(self, *args, **kwargs)

    def getLearnOnOneCell(self):
        """getLearnOnOneCell(self) -> bool"""
        return _experimental.ApicalTiebreakTemporalMemory_getLearnOnOneCell(self)

    def setLearnOnOneCell(self, *args, **kwargs):
        """setLearnOnOneCell(self, learnOnOneCell)"""
        return _experimental.ApicalTiebreakTemporalMemory_setLearnOnOneCell(self, *args, **kwargs)

    def getPermanenceIncrement(self):
        """getPermanenceIncrement(self) -> nupic::algorithms::connections::Permanence"""
        return _experimental.ApicalTiebreakTemporalMemory_getPermanenceIncrement(self)

    def setPermanenceIncrement(self, *args, **kwargs):
        """setPermanenceIncrement(self, arg2)"""
        return _experimental.ApicalTiebreakTemporalMemory_setPermanenceIncrement(self, *args, **kwargs)

    def getPermanenceDecrement(self):
        """getPermanenceDecrement(self) -> nupic::algorithms::connections::Permanence"""
        return _experimental.ApicalTiebreakTemporalMemory_getPermanenceDecrement(self)

    def setPermanenceDecrement(self, *args, **kwargs):
        """setPermanenceDecrement(self, arg2)"""
        return _experimental.ApicalTiebreakTemporalMemory_setPermanenceDecrement(self, *args, **kwargs)

    def getBasalPredictedSegmentDecrement(self):
        """getBasalPredictedSegmentDecrement(self) -> nupic::algorithms::connections::Permanence"""
        return _experimental.ApicalTiebreakTemporalMemory_getBasalPredictedSegmentDecrement(self)

    def setBasalPredictedSegmentDecrement(self, *args, **kwargs):
        """setBasalPredictedSegmentDecrement(self, arg2)"""
        return _experimental.ApicalTiebreakTemporalMemory_setBasalPredictedSegmentDecrement(self, *args, **kwargs)

    def getApicalPredictedSegmentDecrement(self):
        """getApicalPredictedSegmentDecrement(self) -> nupic::algorithms::connections::Permanence"""
        return _experimental.ApicalTiebreakTemporalMemory_getApicalPredictedSegmentDecrement(self)

    def setApicalPredictedSegmentDecrement(self, *args, **kwargs):
        """setApicalPredictedSegmentDecrement(self, arg2)"""
        return _experimental.ApicalTiebreakTemporalMemory_setApicalPredictedSegmentDecrement(self, *args, **kwargs)

    def getMaxSegmentsPerCell(self):
        """getMaxSegmentsPerCell(self) -> nupic::UInt"""
        return _experimental.ApicalTiebreakTemporalMemory_getMaxSegmentsPerCell(self)

    def getMaxSynapsesPerSegment(self):
        """getMaxSynapsesPerSegment(self) -> nupic::UInt"""
        return _experimental.ApicalTiebreakTemporalMemory_getMaxSynapsesPerSegment(self)

    def getCheckInputs(self):
        """getCheckInputs(self) -> bool"""
        return _experimental.ApicalTiebreakTemporalMemory_getCheckInputs(self)

    def setCheckInputs(self, *args, **kwargs):
        """setCheckInputs(self, checkInputs)"""
        return _experimental.ApicalTiebreakTemporalMemory_setCheckInputs(self, *args, **kwargs)

    def _validateCell(self, *args, **kwargs):
        """_validateCell(self, cell) -> bool"""
        return _experimental.ApicalTiebreakTemporalMemory__validateCell(self, *args, **kwargs)

    def write(self, *args, **kwargs):
        """write(self, proto)"""
        return _experimental.ApicalTiebreakTemporalMemory_write(self, *args, **kwargs)

    def read(self, *args, **kwargs):
        """read(self, proto)"""
        return _experimental.ApicalTiebreakTemporalMemory_read(self, *args, **kwargs)

    def __eq__(self, *args, **kwargs):
        """__eq__(self, other) -> bool"""
        return _experimental.ApicalTiebreakTemporalMemory___eq__(self, *args, **kwargs)

    def __ne__(self, *args, **kwargs):
        """__ne__(self, other) -> bool"""
        return _experimental.ApicalTiebreakTemporalMemory___ne__(self, *args, **kwargs)

    def printParameters(self):
        """printParameters(self)"""
        return _experimental.ApicalTiebreakTemporalMemory_printParameters(self)

    def columnForCell(self, *args, **kwargs):
        """columnForCell(self, cell) -> nupic::UInt"""
        return _experimental.ApicalTiebreakTemporalMemory_columnForCell(self, *args, **kwargs)

    def activateCells(self, *args, **kwargs):
        """
        activateCells(self, activeColumnsBegin, activeColumnsEnd, basalReinforceCandidatesBegin, basalReinforceCandidatesEnd, 
            apicalReinforceCandidatesBegin, apicalReinforceCandidatesEnd, 
            basalGrowthCandidatesBegin, basalGrowthCandidatesEnd, apicalGrowthCandidatesBegin, 
            apicalGrowthCandidatesEnd, learn)
        """
        return _experimental.ApicalTiebreakTemporalMemory_activateCells(self, *args, **kwargs)

    def depolarizeCells(self, *args, **kwargs):
        """depolarizeCells(self, basalInputBegin, basalInputEnd, apicalInputBegin, apicalInputEnd, learn=True)"""
        return _experimental.ApicalTiebreakTemporalMemory_depolarizeCells(self, *args, **kwargs)

    basalConnections = _swig_property(_experimental.ApicalTiebreakTemporalMemory_basalConnections_get, _experimental.ApicalTiebreakTemporalMemory_basalConnections_set)
    apicalConnections = _swig_property(_experimental.ApicalTiebreakTemporalMemory_apicalConnections_get, _experimental.ApicalTiebreakTemporalMemory_apicalConnections_set)
    def getActiveCells(self):
        """getActiveCells(self) -> PyObject *"""
        return _experimental.ApicalTiebreakTemporalMemory_getActiveCells(self)

    def getPredictedActiveCells(self):
        """getPredictedActiveCells(self) -> PyObject *"""
        return _experimental.ApicalTiebreakTemporalMemory_getPredictedActiveCells(self)

    def getPredictedCells(self):
        """getPredictedCells(self) -> PyObject *"""
        return _experimental.ApicalTiebreakTemporalMemory_getPredictedCells(self)

    def getWinnerCells(self):
        """getWinnerCells(self) -> PyObject *"""
        return _experimental.ApicalTiebreakTemporalMemory_getWinnerCells(self)

    def cellsForColumn(self, *args, **kwargs):
        """cellsForColumn(self, columnIdx) -> PyObject *"""
        return _experimental.ApicalTiebreakTemporalMemory_cellsForColumn(self, *args, **kwargs)

ApicalTiebreakTemporalMemory_swigregister = _experimental.ApicalTiebreakTemporalMemory_swigregister
ApicalTiebreakTemporalMemory_swigregister(ApicalTiebreakTemporalMemory)

class ApicalTiebreakPairMemory(ApicalTiebreakTemporalMemory):
    """Proxy of C++ nupic::experimental::apical_tiebreak_temporal_memory::ApicalTiebreakPairMemory class"""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args, **kwargs): 
        """
        __init__(self, columnCount, basalInputSize, apicalInputSize, cellsPerColumn=32, activationThreshold=13, 
            initialPermanence=0.21, connectedPermanence=0.50, minThreshold=10, 
            sampleSize=20, permanenceIncrement=0.10, permanenceDecrement=0.10, basalPredictedSegmentDecrement=0.0, 
            apicalPredictedSegmentDecrement=0.0, learnOnOneCell=False, 
            seed=42, maxSegmentsPerCell=255, maxSynapsesPerSegment=255, checkInputs=True) -> ApicalTiebreakPairMemory
        """
        this = _experimental.new_ApicalTiebreakPairMemory(*args, **kwargs)
        try: self.this.append(this)
        except: self.this = this
    def compute(self, *args):
        """
        compute(self, activeColumnsBegin, activeColumnsEnd, basalInputBegin, basalInputEnd, apicalInputBegin, 
            apicalInputEnd, basalGrowthCandidatesBegin, basalGrowthCandidatesEnd, 
            apicalGrowthCandidatesBegin, apicalGrowthCandidatesEnd, learn=True)
        compute(self, activeColumns, basalInput, apicalInput, basalGrowthCandidates, apicalGrowthCandidates, 
            learn=True)
        """
        return _experimental.ApicalTiebreakPairMemory_compute(self, *args)

    def write(self, *args):
        """
        write(self)
        write(self, proto)
        """
        return _experimental.ApicalTiebreakPairMemory_write(self, *args)

    def read(self, *args):
        """
        read(self)
        read(self, proto)
        """
        return _experimental.ApicalTiebreakPairMemory_read(self, *args)

    def __init__(self,
                 columnCount=2048,
                 basalInputSize=0,
                 apicalInputSize=0,
                 cellsPerColumn=32,
                 activationThreshold=13,
                 initialPermanence=0.21,
                 connectedPermanence=0.50,
                 minThreshold=10,
                 sampleSize=20,
                 permanenceIncrement=0.10,
                 permanenceDecrement=0.10,
                 basalPredictedSegmentDecrement=0.00,
                 apicalPredictedSegmentDecrement=0.00,
                 learnOnOneCell=False,
                 maxSegmentsPerCell=255,
                 maxSynapsesPerSegment=255,
                 seed=42,
                 checkInputs=True,
                 basalInputPrepend=False):
      """
      @param columnCount (int)
      The number of minicolumns

      @param basalInputSize (sequence)
      The number of bits in the basal input

      @param apicalInputSize (int)
      The number of bits in the apical input

      @param cellsPerColumn (int)
      Number of cells per column

      @param activationThreshold (int)
      If the number of active connected synapses on a segment is at least this
      threshold, the segment is said to be active.

      @param initialPermanence (float)
      Initial permanence of a new synapse

      @param connectedPermanence (float)
      If the permanence value for a synapse is greater than this value, it is said
      to be connected.

      @param minThreshold (int)
      If the number of potential synapses active on a segment is at least this
      threshold, it is said to be "matching" and is eligible for learning.

      @param sampleSize (int)
      How much of the active SDR to sample with synapses.

      @param permanenceIncrement (float)
      Amount by which permanences of synapses are incremented during learning.

      @param permanenceDecrement (float)
      Amount by which permanences of synapses are decremented during learning.

      @param predictedSegmentDecrement (float)
      Amount by which basal segments are punished for incorrect predictions.

      @param learnOnOneCell (bool)
      Whether to always choose the same cell when bursting a column until the
      next reset occurs.

      @param maxSegmentsPerCell (int)
      The maximum number of segments per cell.

      @param maxSynapsesPerSegment (int)
      The maximum number of synapses per segment.

      @param seed (int)
      Seed for the random number generator.

      @param basalInputPrepend (bool)
      If true, this TM will automatically insert its activeCells and winnerCells
      into the basalInput and basalGrowthCandidates, respectively.
      """

      if basalInputPrepend:
        basalInputSize += columnCount * cellsPerColumn

      self.this = _EXPERIMENTAL.new_ApicalTiebreakPairMemory(
        columnCount, basalInputSize, apicalInputSize,
        cellsPerColumn, activationThreshold,
        initialPermanence, connectedPermanence,
        minThreshold, sampleSize, permanenceIncrement,
        permanenceDecrement, basalPredictedSegmentDecrement,
        apicalPredictedSegmentDecrement,
        learnOnOneCell, seed, maxSegmentsPerCell,
        maxSynapsesPerSegment, checkInputs)

      self.basalInputPrepend = basalInputPrepend


    def __getstate__(self):
      # Save the local attributes but override the C++ temporal memory with the
      # string representation.
      d = dict(self.__dict__)
      d["this"] = self.getCState()
      return d


    def __setstate__(self, state):
      # Create an empty C++ temporal memory and populate it from the serialized
      # string.
      self.this = _EXPERIMENTAL.new_ApicalTiebreakPairMemory()
      if isinstance(state, str):
        self.loadFromString(state)
        self.valueToCategory = {}
      else:
        self.loadFromString(state["this"])
        # Use the rest of the state to set local Python attributes.
        del state["this"]
        self.__dict__.update(state)


    def compute(self,
                activeColumns,
                basalInput=(),
                apicalInput=(),
                basalGrowthCandidates=None,
                apicalGrowthCandidates=None,
                learn=True):
      """
      Perform one time step of the Temporal Memory algorithm.

      @param activeColumns (sequence)
      Sorted list of active columns.

      @param basalInput (sequence)
      Sorted list of active input bits for the basal dendrite segments.

      @param apicalInput (sequence)
      Sorted list of active input bits for the apical dendrite segments

      @param basalGrowthCandidates (sequence)
      List of bits that the active cells may grow new basal synapses to.
      If None, the basalInput is assumed to be growth candidates.

      @param apicalGrowthCandidates (sequence)
      List of bits that the active cells may grow new apical synapses to
      If None, the apicalInput is assumed to be growth candidates.

      @param learn (bool)
      Whether or not learning is enabled
      """

      npBasal = numpy.asarray(basalInput, "uint32")
      npApical = numpy.asarray(apicalInput, "uint32")
      npBasalGrowth = (numpy.asarray(basalGrowthCandidates, "uint32")
                       if basalGrowthCandidates is not None
                       else npBasal)
      npApicalGrowth = (numpy.asarray(apicalGrowthCandidates, "uint32")
                        if apicalGrowthCandidates is not None
                        else npApical)

      if self.basalInputPrepend:
        npBasal = numpy.append(self.getActiveCells(),
                               npBasal + self.numberOfCells())
        npBasalGrowth = numpy.append(self.getWinnerCells(),
                                     npBasalGrowth + self.numberOfCells())

      self.convertedCompute(
        numpy.asarray(activeColumns, "uint32"),
        npBasal, npApical, npBasalGrowth, npApicalGrowth,
        learn)


    @classmethod
    def read(cls, proto):
      instance = cls()
      instance.convertedRead(proto)
      return instance

    def write(self, pyBuilder):
      """Serialize the ApicalTiebreakTemporalMemory instance using capnp.

      :param: Destination ApicalTiebreakTemporalMemoryProto message builder
      """
      reader = ApicalTiebreakTemporalMemoryProto.from_bytes(
        self._writeAsCapnpPyBytes()) # copy
      pyBuilder.from_dict(reader.to_dict())  # copy


    def convertedRead(self, proto):
      """Initialize the ApicalTiebreakTemporalMemory instance from the given
      ApicalTiebreakTemporalMemoryProto reader.

      :param proto: ApicalTiebreakTemporalMemoryProto message reader containing data
                    from a previously serialized ApicalTiebreakTemporalMemory
                    instance.

      """
      self._initFromCapnpPyBytes(proto.as_builder().to_bytes()) # copy * 2

    def _writeAsCapnpPyBytes(self):
        """_writeAsCapnpPyBytes(self) -> PyObject *"""
        return _experimental.ApicalTiebreakPairMemory__writeAsCapnpPyBytes(self)

    def _initFromCapnpPyBytes(self, *args, **kwargs):
        """_initFromCapnpPyBytes(self, pyBytes)"""
        return _experimental.ApicalTiebreakPairMemory__initFromCapnpPyBytes(self, *args, **kwargs)

    def convertedCompute(self, *args, **kwargs):
        """
        convertedCompute(self, py_activeColumns, py_basalInput, py_apicalInput, py_basalGrowthCandidates, py_apicalGrowthCandidates, 
            learn)
        """
        return _experimental.ApicalTiebreakPairMemory_convertedCompute(self, *args, **kwargs)

    def getBasalPredictedCells(self):
        """getBasalPredictedCells(self) -> PyObject *"""
        return _experimental.ApicalTiebreakPairMemory_getBasalPredictedCells(self)

    def getApicalPredictedCells(self):
        """getApicalPredictedCells(self) -> PyObject *"""
        return _experimental.ApicalTiebreakPairMemory_getApicalPredictedCells(self)

    __swig_destroy__ = _experimental.delete_ApicalTiebreakPairMemory
ApicalTiebreakPairMemory_swigregister = _experimental.ApicalTiebreakPairMemory_swigregister
ApicalTiebreakPairMemory_swigregister(ApicalTiebreakPairMemory)

class ApicalTiebreakSequenceMemory(ApicalTiebreakTemporalMemory):
    """Proxy of C++ nupic::experimental::apical_tiebreak_temporal_memory::ApicalTiebreakSequenceMemory class"""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(self) -> ApicalTiebreakSequenceMemory
        __init__(self, columnCount, apicalInputSize=0, cellsPerColumn=32, activationThreshold=13, initialPermanence=0.21, 
            connectedPermanence=0.50, minThreshold=10, sampleSize=20, 
            permanenceIncrement=0.10, permanenceDecrement=0.10, basalPredictedSegmentDecrement=0.0, 
            apicalPredictedSegmentDecrement=0.0, learnOnOneCell=False, seed=42, 
            maxSegmentsPerCell=255, maxSynapsesPerSegment=255, checkInputs=True) -> ApicalTiebreakSequenceMemory
        """
        this = _experimental.new_ApicalTiebreakSequenceMemory(*args)
        try: self.this.append(this)
        except: self.this = this
    def compute(self, *args):
        """
        compute(self, activeColumnsBegin, activeColumnsEnd, apicalInputBegin=None, apicalInputEnd=None, 
            apicalGrowthCandidatesBegin=None, apicalGrowthCandidatesEnd=None, learn=True)
        compute(self, activeColumns, apicalInput={}, apicalGrowthCandidates={}, learn=True)
        """
        return _experimental.ApicalTiebreakSequenceMemory_compute(self, *args)

    def write(self, *args):
        """
        write(self)
        write(self, proto)
        """
        return _experimental.ApicalTiebreakSequenceMemory_write(self, *args)

    def read(self, *args):
        """
        read(self)
        read(self, proto)
        """
        return _experimental.ApicalTiebreakSequenceMemory_read(self, *args)

    def __init__(self,
                 columnCount=2048,
                 apicalInputSize=0,
                 cellsPerColumn=32,
                 activationThreshold=13,
                 initialPermanence=0.21,
                 connectedPermanence=0.50,
                 minThreshold=10,
                 sampleSize=20,
                 permanenceIncrement=0.10,
                 permanenceDecrement=0.10,
                 basalPredictedSegmentDecrement=0.00,
                 apicalPredictedSegmentDecrement=0.00,
                 learnOnOneCell=False,
                 maxSegmentsPerCell=255,
                 maxSynapsesPerSegment=255,
                 seed=42,
                 checkInputs=True,
                 basalInputPrepend=False):
      """
      @param columnCount (int)
      The number of minicolumns

      @param apicalInputSize (int)
      The number of bits in the apical input

      @param cellsPerColumn (int)
      Number of cells per column

      @param activationThreshold (int)
      If the number of active connected synapses on a segment is at least this
      threshold, the segment is said to be active.

      @param initialPermanence (float)
      Initial permanence of a new synapse

      @param connectedPermanence (float)
      If the permanence value for a synapse is greater than this value, it is said
      to be connected.

      @param minThreshold (int)
      If the number of potential synapses active on a segment is at least this
      threshold, it is said to be "matching" and is eligible for learning.

      @param sampleSize (int)
      How much of the active SDR to sample with synapses.

      @param permanenceIncrement (float)
      Amount by which permanences of synapses are incremented during learning.

      @param permanenceDecrement (float)
      Amount by which permanences of synapses are decremented during learning.

      @param predictedSegmentDecrement (float)
      Amount by which basal segments are punished for incorrect predictions.

      @param learnOnOneCell (bool)
      Whether to always choose the same cell when bursting a column until the
      next reset occurs.

      @param maxSegmentsPerCell (int)
      The maximum number of segments per cell.

      @param maxSynapsesPerSegment (int)
      The maximum number of synapses per segment.

      @param seed (int)
      Seed for the random number generator.

      @param basalInputPrepend (bool)
      If true, this TM will automatically insert its activeCells and winnerCells
      into the basalInput and basalGrowthCandidates, respectively.
      """

      self.this = _EXPERIMENTAL.new_ApicalTiebreakSequenceMemory(
        columnCount, apicalInputSize,
        cellsPerColumn, activationThreshold,
        initialPermanence, connectedPermanence,
        minThreshold, sampleSize, permanenceIncrement,
        permanenceDecrement, basalPredictedSegmentDecrement,
        apicalPredictedSegmentDecrement,
        learnOnOneCell, seed, maxSegmentsPerCell,
        maxSynapsesPerSegment, checkInputs)


    def __getstate__(self):
      # Save the local attributes but override the C++ temporal memory with the
      # string representation.
      d = dict(self.__dict__)
      d["this"] = self.getCState()
      return d


    def __setstate__(self, state):
      # Create an empty C++ temporal memory and populate it from the serialized
      # string.
      self.this = _EXPERIMENTAL.new_ApicalTiebreakSequenceMemory()
      if isinstance(state, str):
        self.loadFromString(state)
        self.valueToCategory = {}
      else:
        self.loadFromString(state["this"])
        # Use the rest of the state to set local Python attributes.
        del state["this"]
        self.__dict__.update(state)


    def compute(self,
                activeColumns,
                apicalInput=(),
                apicalGrowthCandidates=None,
                learn=True):
      """
      Perform one time step of the Temporal Memory algorithm.

      @param activeColumns (sequence)
      Sorted list of active columns.

      @param apicalInput (sequence)
      Sorted list of active input bits for the apical dendrite segments

      @param apicalGrowthCandidates (sequence)
      List of bits that the active cells may grow new apical synapses to
      If None, the apicalInput is assumed to be growth candidates.

      @param learn (bool)
      Whether or not learning is enabled
      """

      npApical = numpy.asarray(apicalInput, "uint32")
      npApicalGrowth = (numpy.asarray(apicalGrowthCandidates, "uint32")
                        if apicalGrowthCandidates is not None
                        else npApical)

      self.convertedCompute(
        numpy.asarray(activeColumns, "uint32"),
        npApical, npApicalGrowth,
        learn)


    @classmethod
    def read(cls, proto):
      instance = cls()
      instance.convertedRead(proto)
      return instance

    def write(self, pyBuilder):
      """Serialize the ApicalTiebreakTemporalMemory instance using capnp.

      :param: Destination ApicalTiebreakSequenceMemoryProto message builder
      """
      reader = ApicalTiebreakSequenceMemoryProto.from_bytes(
        self._writeAsCapnpPyBytes()) # copy
      pyBuilder.from_dict(reader.to_dict())  # copy


    def convertedRead(self, proto):
      """Initialize the ApicalTiebreakTemporalMemory instance from the given
      ApicalTiebreakSequenceMemoryProto reader.

      :param proto: ApicalTiebreakSequenceMemoryProto message reader containing data
                    from a previously serialized ApicalTiebreakTemporalMemory
                    instance.

      """
      self._initFromCapnpPyBytes(proto.as_builder().to_bytes()) # copy * 2

    def _writeAsCapnpPyBytes(self):
        """_writeAsCapnpPyBytes(self) -> PyObject *"""
        return _experimental.ApicalTiebreakSequenceMemory__writeAsCapnpPyBytes(self)

    def _initFromCapnpPyBytes(self, *args, **kwargs):
        """_initFromCapnpPyBytes(self, pyBytes)"""
        return _experimental.ApicalTiebreakSequenceMemory__initFromCapnpPyBytes(self, *args, **kwargs)

    def convertedCompute(self, *args, **kwargs):
        """convertedCompute(self, py_activeColumns, py_apicalInput, py_apicalGrowthCandidates, learn)"""
        return _experimental.ApicalTiebreakSequenceMemory_convertedCompute(self, *args, **kwargs)

    def getPredictedCells(self):
        """getPredictedCells(self) -> PyObject *"""
        return _experimental.ApicalTiebreakSequenceMemory_getPredictedCells(self)

    def getNextPredictedCells(self):
        """getNextPredictedCells(self) -> PyObject *"""
        return _experimental.ApicalTiebreakSequenceMemory_getNextPredictedCells(self)

    def getNextBasalPredictedCells(self):
        """getNextBasalPredictedCells(self) -> PyObject *"""
        return _experimental.ApicalTiebreakSequenceMemory_getNextBasalPredictedCells(self)

    def getNextApicalPredictedCells(self):
        """getNextApicalPredictedCells(self) -> PyObject *"""
        return _experimental.ApicalTiebreakSequenceMemory_getNextApicalPredictedCells(self)

    __swig_destroy__ = _experimental.delete_ApicalTiebreakSequenceMemory
ApicalTiebreakSequenceMemory_swigregister = _experimental.ApicalTiebreakSequenceMemory_swigregister
ApicalTiebreakSequenceMemory_swigregister(ApicalTiebreakSequenceMemory)



